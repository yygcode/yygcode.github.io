<?xml version="1.0" encoding="utf-8"?>
xhtml4
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
<head>
<!-- 2020-01-01 Wed 13:03 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>STL源码分析之一：迭代器详解</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="yanyg" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="/themes/bootstrap/4.1.3/css/bootstrap.min.css"/>
<link rel="stylesheet" type="text/css" href="/themes/blogs/css/org-code.css" />
<link rel="stylesheet" type="text/css" href="/themes/blogs/css/blog-bluetopbar.css" />
<script type="text/javascript" src="/themes/mathjax/MathJax.js?config=TeX-AMS_HTML"> </script>
</head>
<body>
<div id="preamble" class="status">
<a href="../index.html">Yanyg - SAN Software Engineer</a>
<div class="sitelinks">
  <a href="archives.html">Archives</a> |
  <a href="theindex.html">Index</a> |
  <a href="tags.html">TAGS</a> |
  <a href="https://github.com/yygcode">Github</a> |
  <a href="../about.html">About Me</a>
</div>
</div>
<div id="content">
<h1 class="title">STL源码分析之一：迭代器详解</h1>
<p>
2007-09-26发布于CSDN： <a href="http://blog.csdn.net/cppgp/article/details/1802227">http://blog.csdn.net/cppgp/article/details/1802227</a>
</p>

<p>
本系列文章将会尽可能的剖析STL实现细节。本文假定读者对象是热爱GP编程、希望探究STL实现的程序员。本系列不适合STL初学者。
</p>

<p>
[本篇分析STL迭代器,在文章最后给出一个拥有迭代器和常用操作的仿STL实现的单链表源码]
</p>

<p>
1.概述
《Design Patterns》中iterator模式的定义如下：提供一种方法，使之能够依序寻访某个
聚合物(容器)所含的各个元素。
</p>

<p>
在STL中，迭代器是一种行为类似指针的对象，可透过与一般指针一致的接口来完成自己的
工作(事实上除了随机迭代器以外，其他迭代器只有比指针更少的操作，但是所有迭代器都有
提领操作(*iterator)、成员访问操作(iterator-&gt;member)、前置递增操作(\+\+iterator)、 后置
递增操作(iterator++)，是容器和算法的粘合剂。同时透过迭代器，向操作者隐藏了具体数据结构
和实现细节。例如，我们要遍历某个容器，可以不必关心其采用的数据结构是数组、链表或者某种
图结构，只需要定义一个迭代器，然后按照如下操作：
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">for</span>(<span class="org-whitespace-space"> </span><span class="org-type">iterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">iter</span><span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>container.begin()<span class="org-whitespace-space"> </span>;<span class="org-whitespace-space">  </span>container.end()<span class="org-whitespace-space"> </span>!=<span class="org-whitespace-space"> </span>iter<span class="org-whitespace-space"> </span>;<span class="org-whitespace-space"> </span>++iter<span class="org-whitespace-space"> </span>)
<span class="org-whitespace-space"> </span>&lt;process&gt;(*iter);
</pre>
</div>
<p>
其中container是任意容器。&lt;process&gt;是准备遍历施加的操作。
按照迭代器可以施行的操作将其分为5种，分别是
</p>
<ol class="org-ol">
<li>输入迭代器(input iterator);</li>
<li>输出迭代器(output iterator);</li>
<li>前向迭代器(forward iterator);</li>
<li>双向迭代器(bidirectional iterator);</li>
<li>随机迭代器(random access iterator)。</li>
</ol>

<p>
当不同的迭代器作为参数传递给对应算法时，算法会根据迭代器特性提供最大优化。例如，STL中的distance()对于不同的迭代器，算法不同，分别如下：
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-whitespace-space"> </span>&lt;<span class="org-keyword">class</span><span class="org-whitespace-space"> </span><span class="org-type">_InputIterator</span>,<span class="org-whitespace-space"> </span><span class="org-keyword">class</span><span class="org-whitespace-space"> </span><span class="org-type">_Distance</span>&gt;
<span class="org-keyword">inline</span><span class="org-whitespace-space"> </span><span class="org-type">void</span><span class="org-whitespace-space"> </span><span class="org-function-name">__distance</span>
(<span class="org-type">_InputIterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">__first</span>,
<span class="org-whitespace-space"> </span><span class="org-type">_InputIterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">__last</span>,
<span class="org-whitespace-space"> </span><span class="org-type">_Distance</span>&amp;<span class="org-whitespace-space"> </span><span class="org-variable-name">__n</span>,
<span class="org-whitespace-space"> </span>input_iterator_tag)
{
<span class="org-whitespace-space">  </span><span class="org-keyword">while</span><span class="org-whitespace-space"> </span>(__first<span class="org-whitespace-space"> </span>!=<span class="org-whitespace-space"> </span>__last)<span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span>++__first;<span class="org-whitespace-space"> </span>++__n;<span class="org-whitespace-space"> </span>}
}

<span class="org-keyword">template</span><span class="org-whitespace-space"> </span>&lt;<span class="org-keyword">class</span><span class="org-whitespace-space"> </span><span class="org-type">_RandomAccessIterator</span>,<span class="org-whitespace-space"> </span><span class="org-keyword">class</span><span class="org-whitespace-space"> </span><span class="org-type">_Distance</span>&gt;
<span class="org-keyword">inline</span><span class="org-whitespace-space"> </span><span class="org-type">void</span><span class="org-whitespace-space"> </span><span class="org-function-name">__distance</span>
(<span class="org-type">_RandomAccessIterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">__first</span>,
<span class="org-whitespace-space"> </span><span class="org-type">_RandomAccessIterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">__last</span>,
<span class="org-whitespace-space"> </span><span class="org-type">_Distance</span>&amp;<span class="org-whitespace-space"> </span><span class="org-variable-name">__n</span>,
<span class="org-whitespace-space"> </span>random_access_iterator_tag)
{
<span class="org-whitespace-space">  </span>__n<span class="org-whitespace-space"> </span>+=<span class="org-whitespace-space"> </span>__last<span class="org-whitespace-space"> </span>-<span class="org-whitespace-space"> </span>__first;
}
<span class="org-keyword">template</span><span class="org-whitespace-space"> </span>&lt;<span class="org-keyword">class</span><span class="org-whitespace-space"> </span><span class="org-type">_InputIterator</span>,<span class="org-whitespace-space"> </span><span class="org-keyword">class</span><span class="org-whitespace-space"> </span><span class="org-type">_Distance</span>&gt;
<span class="org-keyword">inline</span><span class="org-whitespace-space"> </span><span class="org-type">void</span><span class="org-whitespace-space"> </span><span class="org-function-name">distance</span>
(<span class="org-type">_InputIterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">__first</span>,
<span class="org-whitespace-space"> </span><span class="org-type">_InputIterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">__last</span>,
<span class="org-whitespace-space"> </span><span class="org-type">_Distance</span>&amp;<span class="org-whitespace-space"> </span><span class="org-variable-name">__n</span>)
{
<span class="org-whitespace-space">  </span>__distance(__first,<span class="org-whitespace-space"> </span>__last,<span class="org-whitespace-space"> </span>__n,<span class="org-whitespace-space"> </span>iterator_category(__first));
}

</pre>
</div>

<p>
2.STL中迭代器层次关系
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span><span class="org-whitespace-space"> </span><span class="org-type">output_iterator_tag</span>{}
<span class="org-keyword">struct</span><span class="org-whitespace-space"> </span><span class="org-type">input_iterator_tag</span>{}
<span class="org-keyword">struct</span><span class="org-whitespace-space"> </span><span class="org-type">forward_iterator_tag</span><span class="org-whitespace-space"> </span>:<span class="org-whitespace-space"> </span><span class="org-keyword">public</span><span class="org-whitespace-space"> </span><span class="org-type">input_iterator_tag</span><span class="org-whitespace-space"> </span>{};
<span class="org-keyword">struct</span><span class="org-whitespace-space"> </span><span class="org-type">bidirectional_iterator_tag</span><span class="org-whitespace-space"> </span>:<span class="org-whitespace-space"> </span><span class="org-keyword">public</span><span class="org-whitespace-space"> </span><span class="org-type">forward_iterator_tag</span>{}
<span class="org-keyword">struct</span><span class="org-whitespace-space"> </span><span class="org-type">random_accessl_iterator_tag</span><span class="org-whitespace-space"> </span>:<span class="org-whitespace-space"> </span><span class="org-keyword">public</span><span class="org-whitespace-space"> </span><span class="org-type">bidirectional_iterator_tag</span>{}
</pre>
</div>

<p>
3.使用
 OutIt：只能通过存储来间接地拥有一个值V。在输出迭代器中存储一个值后必须将其递增。例如：
  *X++ = V; *X = V,++X; *X = V,X++;
 InIt：如果其值不为end-of-sequence，可以间接的存取它所拥有的值。例如：
  V = *X; V = *X++;
  一旦对其递增，其所有其他拷贝不保证能完成比较、取值、递增等操作。
 FwdIt：假设X是FwdIt，如果*X可变，就可替换InIt。可以同时拥有一个前向迭代器的多份拷贝，它们中的每一份都可以各自间接取值，或者各自进行递增。
 BidIt：可以用它来替换FwdIt，同时可以进行诸如&#x2013;X和X&#x2013;相关的递减操作。
 RanIt：除了有BidIt相关操作之外，可以进行任何指针算术运算。
</p>

<p>
<b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b>*</b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b>
  五类迭代器的详述
<b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b><b>*</b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b></b>
1.输出迭代器(output iterator)
1).struct output_iterator_tag{}
 用来读取有序序列中的元素。既可用来表示将值存储到对象中，也可表示从一个对象中获得它所保存的值。如果需要创建一个新的值序列并且以有序的方式来产生值，可用如下循环语句：
 for( ; &lt;not done&gt; ; ++next )
  *next = &lt;whatever&gt;;
 或者：
 while( &lt;not done&gt; )
 {
  *next++ = &lt;whatever&gt;;
 }
 其中，next表示一个迭代器类型为X的对象；&lt;not done&gt;是一个检测循环是否应该终止的谓词(predicate)；&lt;whatever&gt;是一个表达式，类型为序列中元素的类型T或者可以转化为T的类型。
</p>

<p>
2).所拥有的操作：
 a).提领操作 (*a，作为左值才有效)
 b).前置递增操作 (<del><del>a)
 c).后置递增操作 (a</del></del>)
 d).复制构造函数(copy constructor)
 e).析构函数(destructor)
 f).赋值操作符(assignment operator)
</p>

<p>
3).限制条件
 必须保证输出迭代器在存储每一个元素后得以增加；
 必须保证输出迭代器在两次存储的间隔内增加的次数不得超过一次；
 输入迭代器只在类似 1) 中给出的循环语句中使用。
</p>

<p>
4).操作说明：
 对于输出迭代器，只可以向目的序列一个一个的写入，只能一个一个地赋新值，而且不能对同一序列进行两次遍历。如果在相同位置上进行第二次写入，不能确保这次写入的值会3覆盖前一次写入的值。operator*只有作为左值才有效。Output Iterator无须比较(comparison)操作，无法判断迭代器是否有效，或写入是否成功。使用者唯一可做的就是写入写入再写入。纯粹Output Iterator的一个典型例子就是“将元素写至标准输出装置”，另一个就是Inserters，以后详述。其所有操作如下：
  *iter = value;  //将数值写入迭代器所指位置
  <del><del>iter;   //向前步进（传回新位置）
  iter</del></del>;   //向前步进（传回旧位置）
  TYPE(iter)  //复制迭代器（copy构造函数）
</p>

<p>
5).特性说明
[参数说明]X:迭代器类型，a的类型为X&amp;，T是元素类型，t的类型是T
</p>

<p>
表达式  结果的类型  含义   注释
</p>

<p>
X(a)  X   产生a的一个拷贝  析构函数是可见的
        *X(a)=t与*a=t的作用相同
X u(a)  X&amp;   u是a的一个拷贝
X u=a
</p>

<p>
r=a  X&amp;   a赋值给r  结果*r=t和*a=t作用相同
</p>

<p>
*a=t  void   在序列中存储新元素
</p>

<p>
++r  X&amp;   指向下一个元素  &amp;r = &amp;++r，r不是end-of-sequence
</p>

<p>
r++  const X&amp;  指向下一个元素  &amp;r = &amp;r++
     {X temp = *r; ++r; return temp;}
*r++=t  void
</p>



<p>
2.输入迭代器(input interator)
</p>

<p>
1).struct input_iterator_tag{}
用来产生新的序列，可顺序存取已有值或对已有序列进行排序。可用于如下循环语句：
 for( p = first ; p != last ; ++p )
 {
  &lt;process&gt;(*)p
 }
 其中p、first、last都是迭代器类型X的对象，&lt;process&gt;是一个能接受T类型为参数的函数
2).所拥有的操作：
 a).提领操作 (*a)
 b).成员访问操作 (a-&gt;member)
 c).前置递增操作 (<del><del>a)
 d).后置递增操作 (a</del></del>)
 e).复制构造函数(copy constructor)
 f).析构函数(destructor)
 g).赋值操作符(assignment operator)
</p>

<p>
3).限制条件
 两个迭代器中只有一个具有end-of-sequence值时输入迭代器之间的比较才一定有意义
 输入迭代器只在类似 1) 中给出的循环语句中使用。
</p>

<p>
4).操作说明：
 对于输入迭代器，只能一次一个向前读元素，按此顺序一个个传回元素值，而且只能读一次。如果复制Input Iterator，并使原Input Iterator和新产生的Input Iterator都向前读取，可能会遍历到不同值。纯粹Input Iterator的一个典型例子就是从“标准输入装置读取数据”的迭代器（比如从键盘）。两个Input Iterator占用同一个位置则其相等，但是其传回值不一定相等。其所有操作如下：
   *iter;   //读取实际元素，提领操作
   iter-&gt;member;  //读取实际元素的成员（果T是结构化类型），成员访问操作
   <del><del>iter;   //向前步进（传回新位置），前置递增操作
   iter</del></del>;   //向前步进（传回旧位置），后置递增操作
   iter1 = iter2;  //赋值操作
   iter1 <code>= iter2;  //判断两个迭代器是否相等，a和b在同一值域内
   iter1 !</code> iter2;  //判断两个迭代器是否不等，a和b在同一值域内
   TYPE(iter)  //复制迭代器（copy构造函数）
</p>

<p>
说明：应该尽量使用前置式递增
</p>

<p>
5).特性说明
[参数说明]X:迭代器类型，a的类型为X&amp;，T是元素类型，t的类型是T，m是T的成员，m的类型是M
</p>

<p>
表达式  结果的类型  含义   注释
</p>

<p>
X(a)  X   产生a的一个拷贝  析构函数是可见的
        *X(a)与*a的作用相同
X u(a)  X&amp;   u是a的一个拷贝  创建完成后u等于a
X u=a
</p>

<p>
r=a  X&amp;   a赋值给r  结果r=a
</p>

<p>
a == b  bool   相等比较  a和b在同一值域内
</p>

<p>
a != b  bool   !(a==b)   同上
</p>

<p>
*a  T   从序列中取元素  a不是end-of-sequence
</p>

<p>
a-&gt;m  M   (*a).m   T的成员m
</p>

<p>
++r  X&amp;   指向下一个元素  &amp;r = &amp;++r
</p>

<p>
r++  void   指向下一个元素  &amp;r = &amp;r++
     {X temp = *r; ++r; return temp;}
</p>

<p>
3.前向迭代器(forward iterator)
1).struct forward_iterator_tag{}
 可以比较两个前向迭代器是否相等，同时他们可以都为或都不为end-of-sequence，但是如前，这两个迭代器必须处于同一个值域。同时可以用一个前向迭代器的多个有效拷贝值来指向当前序列中的任意位置。前向迭代器不能回退，不能直接(随机)存取任意元素。可以简单想象它为一个单向链表中元素的指针。
</p>

<p>
2).所拥有的操作：
 a).提领操作
 b).成员操作
 c).前置递增操作 (<del><del>a)
 d).后置递增操作 (a</del></del>)
 e).默认构造函数
 d).复制构造函数(copy constructor)
 e).析构函数(destructor)
 f).赋值操作符(assignment operator)
</p>


<p>
3).操作说明：
 Forward Iterator 是 Output Iterator 和 Input Iterator的结合，具有 Input Iterator 的全部功能和 Output Iterator的大部分功能，事实上在STL中，forward iterator 派生自 input iterator。其所有操作如下：
   *iter;   //存取实际元素
   iter-&gt;member;  //存取实际元素的成员，如果有的话
   <del><del>iter;   //向前步进（传回新位置）
   iter</del></del>;   //向前步进（传回旧位置）
   iter1 <code>= iter2;  //判断两个迭代器是否相等
   iter1 !</code> iter2;  //判断两个迭代器是否不等
   TYPE();   //产生迭代器(default构造函数)
   TYPE(iter);  //复制迭代器（copy构造函数）
   iter1 = iter2;  //赋值
</p>

<p>
Forward Iterator有Output Iterator的大部分功能而非全部功能的原因是某些对Output Iterator有效的程序对Forward Iterator可能无效。有以下两点：
(1)面对Output Iterator无须检查其是否抵达序列尾端，便可直接写入数据。事实上由于Output Iterator不提供比较操作，因此无法将Output Iterator与end-of-sequence相比较。以下循环是正确的：
  while(true)
  {
   *pos = foo();
   ++pos;
  }
</p>

<p>
(2)对于Forward Iterator，必须在提领数据之前确保其有效，因此上述循环对Forward Iterator是错误的。对于Forward Iterator上述循环应改为：
   while( pos != coll.end() )
  {
   *pos = foo();
   ++pos;
  }
而同时，该循环不适用于Output Iterator，因为Output Iterator没有operator!=
</p>


<p>
4).特性说明
[参数说明]注释：X是迭代器类型，a和b的类型为X；r和s的类型为X&amp;；T是元素类型，t的类型为T，m是T的成员，m的类型是M。
</p>


<p>
表达式  结果的类型  含义   注释
X()  X   产生一个默认值  析构函数是可见的，值可以是end-of-sequence
</p>

<p>
X u  X&amp;   u具有默认值  创建完成后 u == a
X u =a
</p>

<p>
X(a)  X   产生a的一个拷贝  析构函数是可见的，*X(a)与*a的作用相同
</p>

<p>
X u(a)  X&amp;   u是a的一个拷贝  创建完成后 u == a
X u =a
</p>

<p>
r = a  X&amp;   a赋值给r  结果 r == a
</p>

<p>
a <code>= b  bool   相等比较  a和b在同一值域内
a !</code> b  bool   !( a == b ) 　
</p>

<p>
*a  T&amp;   从序列中存取元素 a不是end-of-sequence，a <code>= b &lt;==&gt; *a =</code> *b
</p>

<p>
*a = t  T&amp;   在元素中存储  a不是end-of-sequence，a是可变的
</p>

<p>
a -&gt; m  M   (*a).m   T有成员m
</p>

<p>
++r  X&amp;   指向下一个元素  &amp;r = &amp;++r，r不是end-of-sequence，r <code>= s &lt;==&gt; ++r =</code> ++s
</p>

<p>
r++  const X&amp;  {X tmp(r);++r;return tmp;} 　
*r++  void   {T tmp = *r;++r;return tmp;}
</p>


<p>
4.双向迭代器(bidirectional iterator)
1).struct bidirectional_iterator_tag{}
 具有前向迭代器的所有特性，另外还具有逆向移动特性。可以简单想象它为一个双向链表中元素的指针。
</p>

<p>
2).所拥有的操作：
 a).前向迭代器的所有操作
 b).前置递减操作 (&#x2013;a)
 c).后置递减操作 (a&#x2013;)
</p>

<p>
3).操作说明：
 Forward Iterator的所有操作均可用，新增加的操作如下：
   &#x2013;iter;   //只向前一个元素，传回新位置
   iter&#x2013;;   //只向前一个元素，传回旧位置
</p>

<p>
4).特性说明
[参数说明]注释：X是迭代器类型，a和b的类型为X；r和s的类型为X&amp;；T是元素类型，t的类型为T，m是T的成员，m的类型是M。
有Forward Iterator的所有特性，新加特性如下：
</p>

<p>
表达式  结果的类型  含义   注释
&#x2013;r  X&amp;   指向前一个元素  &amp;r = &amp;&#x2013;r，r不是end-of-sequence，r <code>= s &lt;==&gt; --r =</code> &#x2013;s
r&#x2013;  const X&amp;  {X tmp(r);++r;return tmp;} 　
*r++  void   {T tmp = *r;++r;return tmp;}
</p>


<p>
5.随机迭代器(random access iterator)
1).struct random_access_iterator_tag{}
 具有双向迭代器的所有特性，另外还具有支持加减、大小判断、迭代器在序列中的顺序、下标操作迭代器特性。可以简单想象它为一个数组中元素的指针。
</p>

<p>
2).所拥有的操作：
 a).双向迭代器的所有操作
 b).加减操作(a+=n;a-=n;a+n;a-n;a-b;b-a)
 c).大小判断(a&gt;b;a&lt;b;a&gt;=b;a&lt;=b)
 d).下标操作(a[n])
</p>

<p>
3).操作说明：
 Bidirectional Iterator的所有操作均可用，新增加的操作如下：
   iter1 &lt; iter2;
   iter1 &lt;= iter2;
   iter += n;
   iter -= n;
   iter + n;
   n + iter;
   iter - n;
   n - iter;
   iter1 - iter2;
   iter[n]
</p>

<p>
4).特性说明
[参数说明]注释：X是迭代器类型，a和b的类型为X；r和s的类型为X&amp;；T是元素类型，t的类型为T；Dist是X的差距类型
有Forward Iterator的所有特性，新加特性如下：
</p>

<p>
表达式  结果的类型  含义   注释
a &lt; b  bool   从a可以到达b  a和b在同一值域中
a &gt; b  bool   b &lt; a 　
a &lt;= b  bool   !(b &lt; a) 　
a &gt;= b  bool   !(a &lt; b) 　
r += n  X&amp;   {Dist m = n;while(0&lt;m)&#x2013;m,++r;while(m&lt;0)++m,&#x2013;r;return r;}
</p>

<p>
a + n  X   {X tmp(a);tmp += n;return tmp;}
n + a
</p>

<p>
r -= n  X&amp;   r += -n; 　
a - n  X   a + (-n) 　
b - a  Dist   {Dist m = 0;while(a&lt;b)++a,++m;while(b&lt;a)++b;&#x2013;m;return m;} 　
a[n]  T的任意类型  *(a+n)
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span><span class="org-whitespace-space"> </span><span class="org-string">&lt;new&gt;</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">&#36825;&#20010;&#26159;&#38142;&#34920;&#22522;&#26412;&#32467;&#26500;,&#37324;&#38754;&#19981;&#23384;&#20648;&#20219;&#20309;&#19996;&#35199;,&#32431;&#31929;&#20026;&#20102;&#23454;&#29616;&#31639;&#27861;</span>
<span class="org-keyword">struct</span><span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>
{
<span class="org-whitespace-space">  </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">s_Next</span>;
};

<span class="org-comment-delimiter">//</span><span class="org-comment">&#36825;&#20010;&#20989;&#25968;&#22312;prevNode&#33410;&#28857;&#21518;&#38754;&#25554;&#20837;&#26032;&#33410;&#28857;</span><span class="org-whitespace-space"> </span><span class="org-comment">newNode</span>
<span class="org-keyword">inline</span><span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-function-name">InsertAfterNode</span>(<span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">prevNode</span><span class="org-whitespace-space"> </span>,<span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name"><span class="org-whitespace-line">newNode</span></span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">)</span>
{
<span class="org-whitespace-space">  </span>newNode-&gt;s_Next<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>prevNode-&gt;s_Next;<span class="org-whitespace-space">    </span><span class="org-comment-delimiter">//</span><span class="org-comment">newNode&#30340;&#19979;&#19968;&#33410;&#28857;&#20026;prevNode&#30340;&#19979;&#19968;&#33410;&#28857;</span>
<span class="org-whitespace-space">  </span>prevNode-&gt;s_Next<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>newNode;<span class="org-whitespace-space">        </span><span class="org-comment-delimiter">//</span><span class="org-comment">prevNode&#30340;&#19979;&#19968;&#33410;&#28857;&#20026;newNode</span>
<span class="org-whitespace-space">  </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>newNode;<span class="org-whitespace-space">                </span><span class="org-comment-delimiter">//</span><span class="org-comment">&#36820;&#22238;newNode,&#23454;&#29616;&#20018;&#25509;&#31639;&#27861;,&#35814;&#32454;&#35265;&#19979;&#38754;&#30340;[&#27880;&#37322;1]</span>
}

<span class="org-comment-delimiter">/*</span>
<span class="org-whitespace-space">  </span><span class="org-comment">[&#27880;&#37322;1]</span><span class="org-whitespace-space"> </span><span class="org-comment">:</span><span class="org-whitespace-space"> </span><span class="org-comment">&#36825;&#31867;&#31639;&#27861;&#36820;&#22238;&#30340;&#21407;&#22240;&#26159;&#20026;&#20102;&#23454;&#29616;&#38142;&#25509;&#35843;&#29992;,&#20363;&#22914;:</span>
<span class="org-whitespace-space">  </span><span class="org-comment">InsertAfterNode(</span><span class="org-whitespace-space"> </span><span class="org-comment">InsertAfterNode(front,newNode1)</span><span class="org-whitespace-space"> </span><span class="org-comment">,</span><span class="org-whitespace-space"> </span><span class="org-comment">newNode2</span><span class="org-whitespace-space"> </span><span class="org-comment">);</span>
<span class="org-whitespace-space">  </span><span class="org-comment">&#20877;&#27604;&#22914;c&#24211;&#20989;&#25968;strcpy&#31561;&#37117;&#26159;&#36825;&#20010;&#21407;&#22240;,&#20363;&#22914;:</span>
<span class="org-whitespace-space">  </span><span class="org-comment">char</span><span class="org-whitespace-space"> </span><span class="org-comment">buff[128];</span>
<span class="org-whitespace-space">  </span><span class="org-comment">int</span><span class="org-whitespace-space"> </span><span class="org-comment">len</span><span class="org-whitespace-space"> </span><span class="org-comment">=</span><span class="org-whitespace-space"> </span><span class="org-comment">strlen(</span><span class="org-whitespace-space"> </span><span class="org-comment">strcpy(buff,"yanyg")</span><span class="org-whitespace-space"> </span><span class="org-comment">);</span>
<span class="org-comment">*/</span>

<span class="org-comment-delimiter">//</span><span class="org-comment">&#36825;&#20010;&#20989;&#25968;&#24471;&#21040;&#33410;&#28857;node&#30340;&#21069;&#19968;&#33410;&#28857;</span>
<span class="org-keyword">inline</span><span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-function-name">GetPrevious</span>(<span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">front</span><span class="org-whitespace-space"> </span>,<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">n</span><span class="org-variable-name"><span class="org-whitespace-line">ode</span></span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">)</span>
{
<span class="org-whitespace-space">  </span><span class="org-keyword">for</span><span class="org-whitespace-space"> </span>(<span class="org-whitespace-space"> </span>;<span class="org-whitespace-space"> </span>front<span class="org-whitespace-space"> </span>&amp;&amp;<span class="org-whitespace-space"> </span>front-&gt;s_Next<span class="org-whitespace-space"> </span>!=<span class="org-whitespace-space"> </span>node<span class="org-whitespace-space"> </span>;<span class="org-whitespace-space"> </span>front<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>front-&gt;s_Next<span class="org-whitespace-space"> </span>);
<span class="org-whitespace-space">  </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>front;
}

<span class="org-comment-delimiter">//</span><span class="org-comment">&#36825;&#20010;&#20989;&#25968;&#26159;&#21069;&#19968;&#20010;&#20989;&#25968;&#30340;const&#29256;&#26412;</span>
<span class="org-keyword">inline</span><span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-function-name">GetPrevious</span>(<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">front</span><span class="org-whitespace-space"> </span>,<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">SLis</span><span class="org-type"><span class="org-whitespace-line">tBaseNode</span></span><span class="org-whitespace-line">*</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-variable-name"><span class="org-whitespace-line">node</span></span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">)</span>
{
<span class="org-whitespace-space">  </span><span class="org-keyword">for</span><span class="org-whitespace-space"> </span>(<span class="org-whitespace-space"> </span>;<span class="org-whitespace-space"> </span>front<span class="org-whitespace-space"> </span>&amp;&amp;<span class="org-whitespace-space"> </span>front-&gt;s_Next<span class="org-whitespace-space"> </span>!=<span class="org-whitespace-space"> </span>node<span class="org-whitespace-space"> </span>;<span class="org-whitespace-space"> </span>front<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>front-&gt;s_Next<span class="org-whitespace-space"> </span>);
<span class="org-whitespace-space">  </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>front;
}

<span class="org-comment-delimiter">//</span><span class="org-comment">&#36825;&#20010;&#20989;&#25968;&#36870;&#24207;&#38142;&#34920;,&#24182;&#36820;&#22238;&#26368;&#21518;&#19968;&#20010;&#33410;&#28857;</span>
<span class="org-keyword">inline</span><span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-function-name">Reverse</span>(<span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">node</span><span class="org-whitespace-space"> </span>)
{
<span class="org-whitespace-space">  </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">result</span><span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>node;

<span class="org-whitespace-space">  </span>node<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>node-&gt;s_Next;
<span class="org-whitespace-space">  </span>result-&gt;s_Next<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>0;

<span class="org-whitespace-space">  </span><span class="org-keyword">while</span><span class="org-whitespace-space"> </span>(<span class="org-whitespace-space"> </span>node<span class="org-whitespace-space"> </span>)
<span class="org-whitespace-space">    </span>{
<span class="org-whitespace-space">      </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">next</span><span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>node-&gt;s_Next;
<span class="org-whitespace-space">      </span>node-&gt;s_Next<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>result;
<span class="org-whitespace-space">      </span>result<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>node;
<span class="org-whitespace-space">      </span>node<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>next;
<span class="org-whitespace-space">    </span>}

<span class="org-whitespace-space">  </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>result;
}

<span class="org-comment-delimiter">//</span><span class="org-comment">&#35745;&#31639;node&#20043;&#21518;&#30340;&#33410;&#28857;&#20010;&#25968;</span>
<span class="org-keyword">inline</span><span class="org-whitespace-space"> </span><span class="org-type">size_t</span><span class="org-whitespace-space"> </span><span class="org-function-name">ListSize</span>(<span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">node</span><span class="org-whitespace-space"> </span>)
{
<span class="org-whitespace-space">  </span><span class="org-type">size_t</span><span class="org-whitespace-space"> </span><span class="org-variable-name">result</span><span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>0;

<span class="org-whitespace-space">  </span><span class="org-keyword">for</span><span class="org-whitespace-space"> </span>(<span class="org-whitespace-space"> </span>;<span class="org-whitespace-space"> </span>0<span class="org-whitespace-space"> </span>!=<span class="org-whitespace-space"> </span>node<span class="org-whitespace-space"> </span>;<span class="org-whitespace-space"> </span>node<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>node-&gt;s_Next<span class="org-whitespace-space"> </span>,<span class="org-whitespace-space"> </span>++result<span class="org-whitespace-space"> </span>);

<span class="org-whitespace-space">  </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>result;
}

<span class="org-comment-delimiter">//</span><span class="org-comment">&#36825;&#20010;&#27966;&#29983;&#26159;&#38142;&#34920;&#20855;&#20307;&#23384;&#20648;&#30340;&#23545;&#35937;</span>
<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span><span class="org-whitespace-space"> </span><span class="org-type">T</span>&gt;
<span class="org-keyword">struct</span><span class="org-whitespace-space"> </span><span class="org-type">SListNode</span><span class="org-whitespace-space"> </span>:<span class="org-whitespace-space"> </span><span class="org-keyword">public</span><span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>
{
<span class="org-whitespace-space">  </span><span class="org-function-name">SListNode</span>():s_Next(0){}
<span class="org-whitespace-space">  </span><span class="org-function-name">SListNode</span>(<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">T</span>&amp;<span class="org-whitespace-space"> </span><span class="org-variable-name">t</span><span class="org-whitespace-space"> </span>):<span class="org-function-name">s_Data</span>(t){<span class="org-whitespace-space"> </span>s_Next<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>0;<span class="org-whitespace-space"> </span>}
<span class="org-whitespace-space">  </span><span class="org-type">T</span><span class="org-whitespace-space"> </span><span class="org-variable-name">s_Data</span>;
};

<span class="org-comment-delimiter">/************************************************************************</span>
<span class="org-whitespace-space"> </span><span class="org-comment">*</span><span class="org-whitespace-space">    </span><span class="org-comment">&#36825;&#37324;&#23454;&#29616;&#19968;&#20010;&#31616;&#21333;&#30340;&#36845;&#20195;&#22120;</span>
<span class="org-whitespace-space"> </span><span class="org-comment">*</span><span class="org-whitespace-space">    </span><span class="org-comment">&#22914;&#26524;&#24819;&#21644;stl&#23436;&#32654;&#34701;&#21512;</span>
<span class="org-whitespace-space"> </span><span class="org-comment">*</span><span class="org-whitespace-space">    </span><span class="org-comment">&#37027;&#20040;&#38656;&#35201;&#20174;stl&#36845;&#20195;&#22120;&#33795;&#21462;&#26576;&#20123;&#29305;&#24449;&#22411;&#21035;&#20449;&#24687;</span>
<span class="org-whitespace-space"> </span><span class="org-comment">*</span><span class="org-whitespace-space">    </span><span class="org-comment">&#22411;&#21035;&#33795;&#21462;&#19981;&#26159;&#26412;&#31687;&#37325;&#28857;,&#19981;&#20877;&#35814;&#32454;&#35770;&#36848;</span>
<span class="org-whitespace-space"> </span><span class="org-comment">*</span><span class="org-whitespace-space">    </span><span class="org-comment">&#21333;&#38142;&#34920;&#26159;&#19968;&#20010;forward_iterator</span>
<span class="org-whitespace-space"> </span><span class="org-comment">*</span><span class="org-whitespace-space">    </span><span class="org-comment">&#22240;&#27492;&#21482;&#23454;&#29616;</span><span class="org-whitespace-space"> </span><span class="org-comment">iter++/++iter/*iter/iter-&gt;member/==/!=&#20845;&#31181;&#25805;&#20316;</span>
<span class="org-whitespace-space"> </span><span class="org-comment">************************************************************************/</span>
<span class="org-keyword">template</span>&lt;<span class="org-keyword">class</span><span class="org-whitespace-space"> </span><span class="org-type">T</span><span class="org-whitespace-space"> </span>,<span class="org-whitespace-space"> </span><span class="org-keyword">class</span><span class="org-whitespace-space"> </span><span class="org-type">Ref</span><span class="org-whitespace-space"> </span>,<span class="org-whitespace-space"> </span><span class="org-keyword">class</span><span class="org-whitespace-space"> </span><span class="org-type">Ptr</span><span class="org-whitespace-space"> </span>&gt;
<span class="org-keyword">struct</span><span class="org-whitespace-space"> </span><span class="org-type">SList_Iterator</span>
{
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">SList_Iterator</span>&lt;<span class="org-type">T</span>,<span class="org-type">T</span>&amp;,<span class="org-type">T</span>*&gt;<span class="org-whitespace-space"> </span><span class="org-type">iterator</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">SList_Iterator</span>&lt;<span class="org-type">T</span>,<span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">T</span>&amp;,<span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">T</span>*&gt;<span class="org-whitespace-space"> </span><span class="org-type">const_iterator</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">SList_Iterator</span>&lt;<span class="org-type">T</span>,<span class="org-type">Ref</span>,<span class="org-type">Ptr</span>&gt;<span class="org-whitespace-space"> </span><span class="org-type">self</span>;

<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">T</span><span class="org-whitespace-space"> </span><span class="org-type">value_type</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">Ptr</span><span class="org-whitespace-space"> </span><span class="org-type">pointer</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">Ref</span><span class="org-whitespace-space"> </span><span class="org-type">reference</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">SListNode</span>&lt;<span class="org-type">T</span>&gt;<span class="org-whitespace-space"> </span><span class="org-type">list_node</span>;

<span class="org-whitespace-space">  </span><span class="org-function-name">SList_Iterator</span>(<span class="org-whitespace-space"> </span><span class="org-type">list_node</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">x</span><span class="org-whitespace-space"> </span>):<span class="org-function-name">s_Node</span>(x){}
<span class="org-whitespace-space">  </span><span class="org-function-name">SList_Iterator</span>():s_Node(0){}
<span class="org-whitespace-space">  </span><span class="org-function-name">SList_Iterator</span>(<span class="org-whitespace-space"> </span><span class="org-type">const_iterator</span>&amp;<span class="org-whitespace-space"> </span><span class="org-variable-name">x</span><span class="org-whitespace-space"> </span>):<span class="org-function-name">s_Node</span>(x.s_Node){}

<span class="org-whitespace-space">  </span><span class="org-type">reference</span><span class="org-whitespace-space"> </span><span class="org-keyword">operator</span><span class="org-function-name">*</span>()<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>((<span class="org-type">list_node</span>*)s_Node)-&gt;s_Data;<span class="org-whitespace-space"> </span>}
<span class="org-whitespace-space">  </span><span class="org-type">pointer</span><span class="org-whitespace-space"> </span><span class="org-keyword">operator</span><span class="org-function-name">-&gt;</span>()<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>&amp;(<span class="org-keyword">operator</span>*());<span class="org-whitespace-space"> </span>}

<span class="org-whitespace-space">  </span><span class="org-type">self</span>&amp;<span class="org-whitespace-space"> </span><span class="org-keyword">operator</span><span class="org-function-name">++</span>()
<span class="org-whitespace-space">  </span>{
<span class="org-whitespace-space">    </span>s_Node<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>s_Node-&gt;s_Next;
<span class="org-whitespace-space">    </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>*<span class="org-keyword">this</span>;
<span class="org-whitespace-space">  </span>}

<span class="org-whitespace-space">  </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">self</span><span class="org-whitespace-space"> </span><span class="org-keyword">operator</span><span class="org-function-name">++</span>(<span class="org-type">int</span>)
<span class="org-whitespace-space">  </span>{
<span class="org-whitespace-space">    </span><span class="org-type">self</span><span class="org-whitespace-space"> </span><span class="org-variable-name">tmp</span>(*<span class="org-keyword">this</span>);
<span class="org-whitespace-space">    </span>s_Node<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>s_Node-&gt;s_Next;

<span class="org-whitespace-space">    </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>tmp;
<span class="org-whitespace-space">  </span>}

<span class="org-whitespace-space">  </span><span class="org-type">bool</span><span class="org-whitespace-space"> </span><span class="org-keyword">operator</span><span class="org-function-name">==</span>(<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">SList_Iterator</span>&amp;<span class="org-whitespace-space"> </span><span class="org-variable-name">x</span><span class="org-whitespace-space"> </span>){<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>s_Node<span class="org-whitespace-space"> </span>==<span class="org-whitespace-space"> </span>x.s_Node;<span class="org-whitespace-space"> </span>}
<span class="org-whitespace-space">  </span><span class="org-type">bool</span><span class="org-whitespace-space"> </span><span class="org-keyword">operator</span><span class="org-function-name">!=</span>(<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">SList_Iterator</span>&amp;<span class="org-whitespace-space"> </span><span class="org-variable-name">x</span><span class="org-whitespace-space"> </span>){<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>s_Node<span class="org-whitespace-space"> </span>!=<span class="org-whitespace-space"> </span>x.s_Node;<span class="org-whitespace-space"> </span>}

<span class="org-whitespace-space">  </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">s_Node</span>;
};

<span class="org-comment-delimiter">//</span><span class="org-comment">&#21333;&#38142;&#34920;&#31867;&#23454;&#29616;</span>
<span class="org-keyword">template</span><span class="org-whitespace-space"> </span>&lt;<span class="org-whitespace-space"> </span><span class="org-keyword">class</span><span class="org-whitespace-space"> </span><span class="org-type">T</span><span class="org-whitespace-space"> </span>&gt;
<span class="org-keyword">class</span><span class="org-whitespace-space"> </span><span class="org-type">SList</span>
{
<span class="org-keyword">public</span>:
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">T</span><span class="org-whitespace-space"> </span><span class="org-type">value_type</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">value_type</span>*<span class="org-whitespace-space"> </span><span class="org-type">pointer</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">value_type</span>*<span class="org-whitespace-space"> </span><span class="org-type">const_pointer</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">value_type</span>&amp;<span class="org-whitespace-space"> </span><span class="org-type">reference</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">value_type</span>&amp;<span class="org-whitespace-space"> </span><span class="org-type">const_reference</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">size_t</span><span class="org-whitespace-space"> </span><span class="org-type">size_type</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">ptrdiff_t</span><span class="org-whitespace-space"> </span><span class="org-type">difference_type</span>;

<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">SList_Iterator</span>&lt;<span class="org-whitespace-space"> </span><span class="org-type">T</span><span class="org-whitespace-space"> </span>,<span class="org-whitespace-space"> </span><span class="org-type">T</span>&amp;<span class="org-whitespace-space"> </span>,<span class="org-whitespace-space"> </span><span class="org-type">T</span>*<span class="org-whitespace-space"> </span>&gt;<span class="org-whitespace-space"> </span><span class="org-type">iterator</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">SList_Iterator</span>&lt;<span class="org-whitespace-space"> </span><span class="org-type">T</span>,<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">T</span>&amp;,<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">T</span>*<span class="org-whitespace-space"> </span>&gt;<span class="org-whitespace-space"> </span><span class="org-type">const_iterator</span>;


<span class="org-keyword">private</span>:
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">SListNode</span>&lt;<span class="org-type">T</span>&gt;<span class="org-whitespace-space"> </span><span class="org-type">list_node</span>;
<span class="org-whitespace-space">  </span><span class="org-keyword">typedef</span><span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span><span class="org-whitespace-space"> </span><span class="org-type">list_node_base</span>;

<span class="org-whitespace-space">  </span><span class="org-type">list_node_base</span><span class="org-whitespace-space"> </span><span class="org-variable-name">m_Head</span>;

<span class="org-keyword">public</span>:
<span class="org-whitespace-space">  </span><span class="org-function-name">SList</span>()<span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span>m_Head.s_Next<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>0;<span class="org-whitespace-space"> </span>}<span class="org-whitespace-space">    </span><span class="org-comment-delimiter">//</span><span class="org-comment">&#21021;&#22987;&#21270;</span>
<span class="org-whitespace-space">  </span>~<span class="org-function-name">SList</span>(){<span class="org-whitespace-space"> </span>clear();<span class="org-whitespace-space"> </span>}<span class="org-whitespace-space">        </span><span class="org-comment-delimiter">//</span><span class="org-comment">&#21024;&#38500;&#20869;&#23384;</span>

<span class="org-whitespace-space">  </span><span class="org-type">iterator</span><span class="org-whitespace-space"> </span><span class="org-function-name">begin</span>()<span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>iterator(<span class="org-whitespace-space"> </span>(<span class="org-type">list_node</span>*)m_Head.s_Next<span class="org-whitespace-space"> </span>);<span class="org-whitespace-space"> </span>}
<span class="org-whitespace-space">  </span><span class="org-type">iterator</span><span class="org-whitespace-space"> </span><span class="org-function-name">end</span>()<span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>iterator(0);<span class="org-whitespace-space"> </span>}
<span class="org-whitespace-space">  </span><span class="org-type">const_iterator</span><span class="org-whitespace-space"> </span><span class="org-function-name">begin</span>()<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>const_iterator(<span class="org-whitespace-space"> </span>(<span class="org-type">list_node</span>*)m_Head.s_Nex<span class="org-whitespace-line">t</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">);</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">}</span>
<span class="org-whitespace-space">  </span><span class="org-type">const_iterator</span><span class="org-whitespace-space"> </span><span class="org-function-name">end</span>()<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>const_iterator(0);<span class="org-whitespace-space"> </span>}
<span class="org-whitespace-space">  </span><span class="org-type">size_t</span><span class="org-whitespace-space"> </span><span class="org-function-name">size</span>()<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>ListSize(m_Head.s_Next);<span class="org-whitespace-space"> </span>}
<span class="org-whitespace-space">  </span><span class="org-type">size_t</span><span class="org-whitespace-space"> </span><span class="org-function-name">max_size</span>()<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>size_t(-1);<span class="org-whitespace-space"> </span>}
<span class="org-whitespace-space">  </span><span class="org-type">bool</span><span class="org-whitespace-space"> </span><span class="org-function-name">empty</span>()<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>0<span class="org-whitespace-space"> </span>==<span class="org-whitespace-space"> </span>m_Head.s_Next;<span class="org-whitespace-space"> </span>}

<span class="org-whitespace-space">  </span><span class="org-type">reference</span><span class="org-whitespace-space"> </span><span class="org-function-name">front</span>()<span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>((<span class="org-type">list_node</span>*)m_Head.s_Next)-&gt;s_Data;<span class="org-whitespace-space"> </span>}
<span class="org-whitespace-space">  </span><span class="org-type">const_reference</span><span class="org-whitespace-space"> </span><span class="org-function-name">front</span>()<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>((<span class="org-type">list_node</span>*)m_Head.s_Next)-&gt;s_Data;<span class="org-whitespace-space"> </span>}

<span class="org-whitespace-space">  </span><span class="org-type">void</span><span class="org-whitespace-space"> </span><span class="org-function-name">push_front</span>(<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">value_type</span>&amp;<span class="org-whitespace-space"> </span><span class="org-variable-name">t</span><span class="org-whitespace-space"> </span>)<span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span>InsertAfterNode(&amp;m_Head,<span class="org-keyword">new</span><span class="org-whitespace-space"> </span><span class="org-type">list_node</span><span class="org-whitespace-line">(t));</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">}</span>
<span class="org-whitespace-space">  </span><span class="org-type">void</span><span class="org-whitespace-space"> </span><span class="org-function-name">pop_front</span>()<span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-type">list_node</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">node</span><span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>(<span class="org-type">list_node</span>*)(m_Head.s_Next);<span class="org-whitespace-space"> </span>m_Head.s_Nex<span class="org-whitespace-line">t</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">=</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">node-&gt;s_Next;</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-keyword"><span class="org-whitespace-line">delete</span></span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">(</span><span class="org-type"><span class="org-whitespace-line">list_node</span></span><span class="org-whitespace-line">*)node;</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">}</span>

<span class="org-whitespace-space">  </span><span class="org-type">iterator</span><span class="org-whitespace-space"> </span><span class="org-function-name">previous</span>(<span class="org-whitespace-space"> </span><span class="org-type">const_iterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">pos</span><span class="org-whitespace-space"> </span>)<span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>iterator(GetPrevious(m_Head.s<span class="org-whitespace-line">_Next,pos));</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">}</span>
<span class="org-whitespace-space">  </span><span class="org-type">const_iterator</span><span class="org-whitespace-space"> </span><span class="org-function-name">previous</span>(<span class="org-whitespace-space"> </span><span class="org-type">const_iterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">pos</span><span class="org-whitespace-space"> </span>)<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>const_iterator(Ge<span class="org-whitespace-line">tPrevious(m_Head.s_Next,pos));</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">}</span>

<span class="org-whitespace-space">  </span><span class="org-type">iterator</span><span class="org-whitespace-space"> </span><span class="org-function-name">insert</span>(<span class="org-whitespace-space"> </span><span class="org-type">iterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">pos</span>,<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">value_type</span>&amp;<span class="org-whitespace-space"> </span><span class="org-variable-name">x</span><span class="org-whitespace-space"> </span>){<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>iterator((<span class="org-type">list_no</span><span class="org-type"><span class="org-whitespace-line">de</span></span><span class="org-whitespace-line">*)InsertAfterNode(</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">GetPrevious(&amp;m_Head,pos.s_Node),</span><span class="org-keyword"><span class="org-whitespace-line">new</span></span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-type"><span class="org-whitespace-line">list_node</span></span><span class="org-whitespace-line">(x)));</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">}</span>
<span class="org-whitespace-space">  </span><span class="org-type">iterator</span><span class="org-whitespace-space"> </span><span class="org-function-name">insert_after</span>(<span class="org-whitespace-space"> </span><span class="org-type">iterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">pos</span>,<span class="org-whitespace-space"> </span><span class="org-keyword">const</span><span class="org-whitespace-space"> </span><span class="org-type">value_type</span>&amp;<span class="org-whitespace-space"> </span><span class="org-variable-name">x</span><span class="org-whitespace-space"> </span>){<span class="org-whitespace-space"> </span><span class="org-keyword">return</span><span class="org-whitespace-space"> </span>iterator(<span class="org-whitespace-space"> </span>(<span class="org-type"><span class="org-whitespace-line">list_node</span></span><span class="org-whitespace-line">*)InsertAfterNode(pos.s_Node,</span><span class="org-keyword"><span class="org-whitespace-line">new</span></span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-type"><span class="org-whitespace-line">list_node</span></span><span class="org-whitespace-line">(x)</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">)</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">);</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">}</span>
<span class="org-whitespace-space">  </span><span class="org-type">void</span><span class="org-whitespace-space"> </span><span class="org-function-name">erase</span>(<span class="org-whitespace-space"> </span><span class="org-type">iterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">pos</span><span class="org-whitespace-space"> </span>){<span class="org-whitespace-space"> </span><span class="org-type">SListBaseNode</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">temp</span><span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>GetPrevious(&amp;m_Head,pos.s_No<span class="org-whitespace-line">de);</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">temp-&gt;s_Next</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">=</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">pos.s_Node-&gt;s_Next;</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-keyword"><span class="org-whitespace-line">delete</span></span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">(</span><span class="org-type"><span class="org-whitespace-line">list_node</span></span><span class="org-whitespace-line">*)pos.s_Node;</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">}</span>
<span class="org-whitespace-space">  </span><span class="org-type">void</span><span class="org-whitespace-space"> </span><span class="org-function-name">erase_after</span>(<span class="org-whitespace-space"> </span><span class="org-type">iterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">pos</span><span class="org-whitespace-space"> </span>)<span class="org-whitespace-space"> </span>{<span class="org-whitespace-space"> </span><span class="org-type">iterator</span><span class="org-whitespace-space"> </span><span class="org-variable-name">tmp</span>(pos);<span class="org-whitespace-space"> </span>++pos;<span class="org-whitespace-space"> </span>tmp.s_Node-&gt;s_Nex<span class="org-whitespace-line">t</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">=</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">pos.s_Node-&gt;s_Next;</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-keyword"><span class="org-whitespace-line">delete</span></span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">(</span><span class="org-type"><span class="org-whitespace-line">list_node</span></span><span class="org-whitespace-line">*)pos.s_Node;</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">}</span>

<span class="org-whitespace-space">  </span><span class="org-type">void</span><span class="org-whitespace-space"> </span><span class="org-function-name">reverse</span>(){<span class="org-whitespace-space"> </span>m_Head.s_Next<span class="org-whitespace-space"> </span>=<span class="org-whitespace-space"> </span>Reverse(m_Head.s_Next);<span class="org-whitespace-space"> </span>}

<span class="org-whitespace-space">  </span><span class="org-type">void</span><span class="org-whitespace-space"> </span><span class="org-function-name">clear</span>(){<span class="org-whitespace-space"> </span><span class="org-type">list_node_base</span>*<span class="org-whitespace-space"> </span><span class="org-variable-name">node</span>=m_Head.s_Next;<span class="org-whitespace-space"> </span><span class="org-keyword">for</span>(;0!=node;node=m_Head.s_N<span class="org-whitespace-line">ext)m_Head.s_Next=node-&gt;s_Next,</span><span class="org-keyword"><span class="org-whitespace-line">delete</span></span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">(</span><span class="org-type"><span class="org-whitespace-line">list_node</span></span><span class="org-whitespace-line">*)node;</span><span class="org-whitespace-space"><span class="org-whitespace-line"> </span></span><span class="org-whitespace-line">}</span>
};
</pre>
</div>

<script src="https://utteranc.es/client.js"
        repo="yygcode/yygcode.github.io"
        issue-term="pathname"
        label=" Utterances"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>
</div>
<div id="postamble" class="status">
<div class="copyright">
2012-2020 Copyright&copy; <i> YANYG - Powered by Emacs Orgmode</i>
</div>
</div>
</body>
</html>
