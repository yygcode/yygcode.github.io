<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
<head>
<!-- 2018-05-17 Thu 23:41 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>排序算法</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="yanyg" />
<link rel="stylesheet" type="text/css" href="../r/org-code.css" />
<link rel="stylesheet" type="text/css" href="../r/blog-bluetopbar.css" />
<script type="text/javascript" src="../r/MathJax.js?config=TeX-AMS_HTML"> </script>
<script type="text/javascript" src="../r/bootstrap.min.js"></script>
<script type="text/javascript" src="../r/jquery.stickytableheaders.min.js"></script>
</head>
<body>
<div id="preamble" class="status">
<a href="../index.html">Yanyg - SAN Software Engineer</a>
<div class="sitelinks">
  <a href="archives.html">Archives</a> |
  <a href="theindex.html">Index</a> |
  <a href="tags.html">TAGS</a> |
  <a href="https://github.com/yygcode">Github</a> |
  <a href="../about.html">About Me</a>
</div>
</div>
<div id="content">
<h1 class="title">排序算法</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge8945ea">1. 内部排序</a>
<ul>
<li><a href="#orgacf8f56">1.1. 插入排序</a>
<ul>
<li><a href="#orgbc68486">1.1.1. 计算机编程艺术</a></li>
<li><a href="#org08f4de4">1.1.2. WIKI</a></li>
<li><a href="#org5e837bd">1.1.3. C语言实现</a></li>
</ul>
</li>
<li><a href="#org9cb62ed">1.2. 冒泡排序(交换排序)</a>
<ul>
<li><a href="#orgdf2ff2f">1.2.1. 计算机编程艺术</a></li>
<li><a href="#org717734f">1.2.2. WIKI</a></li>
<li><a href="#orgd25b7cb">1.2.3. C语言实现</a></li>
<li><a href="#org650cca5">1.2.4. C语言实现旗标版(性能优化)</a></li>
</ul>
</li>
<li><a href="#org6c1b9e1">1.3. 选择排序</a>
<ul>
<li><a href="#org09e9d84">1.3.1. 计算机编程艺术</a></li>
<li><a href="#org0c06d16">1.3.2. C语言实现</a></li>
</ul>
</li>
<li><a href="#orgec0475b">1.4. 合并排序</a>
<ul>
<li><a href="#org5c60642">1.4.1. 计算机编程艺术</a>
<ul>
<li><a href="#orgc2c9d8f">1.4.1.1. 有序文件两路合并</a></li>
<li><a href="#org5e8344c">1.4.1.2. 自然的两路合并排序</a></li>
</ul>
</li>
<li><a href="#orge7b5e36">1.4.2. C语言实现</a></li>
</ul>
</li>
<li><a href="#org6827239">1.5. 快速排序</a></li>
<li><a href="#org67c0776">1.6. 希尔排序</a></li>
<li><a href="#org9a3e2a5">1.7. 堆排序</a></li>
<li><a href="#orgb15a273">1.8. 桶排序</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orge8945ea" class="outline-2">
<h2 id="orge8945ea"><span class="section-number-2">1</span> 内部排序</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgacf8f56" class="outline-3">
<h3 id="orgacf8f56"><span class="section-number-3">1.1</span> 插入排序</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-orgbc68486" class="outline-4">
<h4 id="orgbc68486"><span class="section-number-4">1.1.1</span> 计算机编程艺术</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
直接插入排序: 重新排列记录R<sub>1</sub>, &#x2026;, R<sub>N</sub>到适当位置，排序完成后他们的键将处于有序状态：K<sub>1</sub>&le; &#x2026; &le;K<sub>N</sub>
</p>

<p>
S1. [对j循环] 对j=2, 3, &#x2026;, N执行S2到S5，然后结束算法；<br />
S2. [设定i, K, R] 置 i &larr; j-1，K &larr; K<sub>j</sub>，
R &larr; R<sub>j</sub>；<br />
S3. [比较K:K<sub>i</sub>] 如果K&ge;K<sub>i</sub>转到S5（已经找到R期望的位置）；<br />
S4. [移动R<sub>i</sub>,减小i] 置 R<sub>i+1</sub> &larr; R<sub>i</sub>，然后i &larr; i-1, 如果
i &larr; &gt; 0返回S3（如果i=0，则K是目前找到的最小键，所以记录R属于位置1）；<br />
S5. [R进入R<sub>i+1</sub>] 置 R<sub>i+1</sub>&larr;R。
</p>
</div>
</div>

<div id="outline-container-org08f4de4" class="outline-4">
<h4 id="org08f4de4"><span class="section-number-4">1.1.2</span> WIKI</h4>
<div class="outline-text-4" id="text-1-1-2">
<blockquote>
<ul class="org-ul">
<li><a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">https://zh.wikipedia.org/wiki/插入排序</a></li>
</ul>
<p>
插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org5e837bd" class="outline-4">
<h4 id="org5e837bd"><span class="section-number-4">1.1.3</span> C语言实现</h4>
<div class="outline-text-4" id="text-1-1-3">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">sort_insertion - sort algorithm by insertion</span>
<span class="org-comment"> * @array - starting pointer of integer array</span>
<span class="org-comment"> * @n - size of array @array</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">sort_insertion</span>(<span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>)
{
        <span class="org-type">size_t</span> <span class="org-variable-name">i</span>, <span class="org-variable-name">j</span>;
        <span class="org-type">int</span> <span class="org-variable-name">v</span>;

        <span class="org-keyword">for</span> (i = 1; i &lt; n; ++i) {
                v = array[i];
                <span class="org-comment-delimiter">/* </span><span class="org-comment">check j &lt; i then loop break after j underflow, because</span>
<span class="org-comment">                 * we need do loop for j == 0.</span>
<span class="org-comment">                 </span><span class="org-comment-delimiter">*/</span>
                <span class="org-keyword">for</span> (j = i - 1; j &lt; i; --j) {
                        <span class="org-keyword">if</span> (v &gt;= array[j]) {
                                <span class="org-keyword">break</span>;
                        }
                        array[j+1] = array[j];
                }

                <span class="org-comment-delimiter">/* </span><span class="org-comment">correction is @array[j+1].</span>
<span class="org-comment">                 * j+1 is corrected position even if j underflowed</span>
<span class="org-comment">                 </span><span class="org-comment-delimiter">*/</span>
                array[j+1] = v;
        }
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">print_array</span>(<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">str</span>, <span class="org-keyword">const</span> <span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>)
{
        <span class="org-type">size_t</span> <span class="org-variable-name">i</span>;

        printf(<span class="org-string">"%s:"</span>, str);
        <span class="org-keyword">for</span> (i = 0; i &lt; n; ++i) {
                printf(<span class="org-string">" %d"</span>, array[i]);
        }
        printf(<span class="org-string">"\n"</span>);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[argc])
{
        <span class="org-type">int</span> <span class="org-variable-name">array</span>[] = {250, 178, 473, 128, 852, 367, 178, 542, 250};
        <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = <span class="org-keyword">sizeof</span>(array)/<span class="org-keyword">sizeof</span>(array[0]);

        print_array(<span class="org-string">"before sort"</span>, array, n);
        sort_insertion(array, n);
        print_array(<span class="org-string">"after  sort"</span>, array, n);

        <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9cb62ed" class="outline-3">
<h3 id="org9cb62ed"><span class="section-number-3">1.2</span> 冒泡排序(交换排序)</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orgdf2ff2f" class="outline-4">
<h4 id="orgdf2ff2f"><span class="section-number-4">1.2.1</span> 计算机编程艺术</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
冒泡排序: 重新排列记录R<sub>1</sub>, &#x2026;, R<sub>N</sub>到适当位置，排序完成后他们的键将处于有序状态：K<sub>1</sub>&le; &#x2026; &le;K<sub>N</sub>
</p>

<p>
B1. [初始化BOUND] 置BOUND &larr; N (BOUND是尚不知其记录是否已处于最终位置上的最高小标；这表示此刻我们尚一无所知)；<br />
B2. [对j进行循环] 置 t &larr; 0，对 j=1, 2, &#x2026;, BOUND-1执行步骤B3，然后转到B4，但如果BOUND=1，则直接跳转到B4；<br />
B3. [比较/交换R<sub>j</sub>:R<sub>j+1</sub>] 如果K<sub>j</sub> &lt; K<sub>j+1</sub>，则交换
R<sub>j</sub>&larr;&rarr;R<sub>j+1</sub>，并置 t&larr;j；<br />
B4. [是否还要交换？] 如果 t&larr;0，则此算法终止，否则置
BOUND &larr; t，并返回到B2；
</p>
</div>
</div>

<div id="outline-container-org717734f" class="outline-4">
<h4 id="org717734f"><span class="section-number-4">1.2.2</span> WIKI</h4>
<div class="outline-text-4" id="text-1-2-2">
<blockquote>
<ul class="org-ul">
<li><a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">https://zh.wikipedia.org/wiki/冒泡排序</a></li>
</ul>

<p>
冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。
</p>

<p>
冒泡排序对n个项目需要O(n<sup>2</sup>)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。
</p>

<p>
冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要O(n<sup>2</sup>)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行O(n<sup>2</sup>)，而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。
</p>

<p>
冒泡排序算法的运作如下：
</p>

<ol class="org-ol">
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，</li>
</ol>
<p>
最后的元素会是最大的数。
</p>
<ol class="org-ol">
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
<li>由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。</li>
</ol>
</blockquote>
</div>
</div>

<div id="outline-container-orgd25b7cb" class="outline-4">
<h4 id="orgd25b7cb"><span class="section-number-4">1.2.3</span> C语言实现</h4>
<div class="outline-text-4" id="text-1-2-3">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">swap_int_nocheck</span>(<span class="org-type">int</span> *<span class="org-variable-name">a</span>, <span class="org-type">int</span> *<span class="org-variable-name">b</span>)
{
        <span class="org-type">int</span> <span class="org-variable-name">v</span> = *a;
        *a = *b;
        *b = v;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">sort_bubble - sort algorithm by bubbling</span>
<span class="org-comment"> * @array - starting pointer of integer array</span>
<span class="org-comment"> * @n - size of array @array</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">sort_bubble</span>(<span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>)
{
        <span class="org-type">size_t</span> <span class="org-variable-name">i</span>, <span class="org-variable-name">j</span>;

        <span class="org-keyword">for</span> (i = 1; i &lt; n; ++i) {
                <span class="org-keyword">for</span> (j = 0; j &lt; n - i; ++j) {
                        <span class="org-keyword">if</span> (array[j] &gt; array[j+1]) {
                                swap_int_nocheck(array+j, array+j+1);
                        }
                }
        }
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">print_array</span>(<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">str</span>, <span class="org-keyword">const</span> <span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>)
{
        <span class="org-type">size_t</span> <span class="org-variable-name">i</span>;

        printf(<span class="org-string">"%s:"</span>, str);
        <span class="org-keyword">for</span> (i = 0; i &lt; n; ++i) {
                printf(<span class="org-string">" %d"</span>, array[i]);
        }
        printf(<span class="org-string">"\n"</span>);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[argc])
{
        <span class="org-type">int</span> <span class="org-variable-name">array</span>[] = {250, 178, 473, 128, 852, 367, 178, 542, 250};
        <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = <span class="org-keyword">sizeof</span>(array)/<span class="org-keyword">sizeof</span>(array[0]);

        print_array(<span class="org-string">"before sort_bubble"</span>, array, n);
        sort_bubble(array, n);
        print_array(<span class="org-string">"after  sort_bubble"</span>, array, n);

        <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org650cca5" class="outline-4">
<h4 id="org650cca5"><span class="section-number-4">1.2.4</span> C语言实现旗标版(性能优化)</h4>
<div class="outline-text-4" id="text-1-2-4">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">swap_int_nocheck</span>(<span class="org-type">int</span> *<span class="org-variable-name">a</span>, <span class="org-type">int</span> *<span class="org-variable-name">b</span>)
{
        <span class="org-type">int</span> <span class="org-variable-name">v</span> = *a;
        *a = *b;
        *b = v;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">sort_bubble - sort algorithm by bubbling</span>
<span class="org-comment"> * @array - starting pointer of integer array</span>
<span class="org-comment"> * @n - size of array @array</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">sort_bubble</span>(<span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>)
{
        <span class="org-type">size_t</span> <span class="org-variable-name">i</span>, <span class="org-variable-name">j</span>, <span class="org-variable-name">t</span>;

        <span class="org-keyword">while</span> (n) {
                t = 0;
                <span class="org-keyword">for</span> (i = 0; i &lt; n - 1; ++i) {
                        <span class="org-keyword">if</span> (array[i] &gt; array[i+1]) {
                                swap_int_nocheck(array+i, array+i+1);
                                <span class="org-comment-delimiter">/* </span><span class="org-comment">we use i+1 because starting-index is 0 </span><span class="org-comment-delimiter">*/</span>
                                t = i + 1;
                        }
                }
                <span class="org-comment-delimiter">/* </span><span class="org-comment">update @n to @t because @t is the last swapped pair</span>
<span class="org-comment">                 * @n will set to 0 to break outter loop if no swap happened.</span>
<span class="org-comment">                 </span><span class="org-comment-delimiter">*/</span>
                n = t;
        }
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">print_array</span>(<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">str</span>, <span class="org-keyword">const</span> <span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>)
{
        <span class="org-type">size_t</span> <span class="org-variable-name">i</span>;

        printf(<span class="org-string">"%s:"</span>, str);
        <span class="org-keyword">for</span> (i = 0; i &lt; n; ++i) {
                printf(<span class="org-string">" %d"</span>, array[i]);
        }
        printf(<span class="org-string">"\n"</span>);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[argc])
{
        <span class="org-type">int</span> <span class="org-variable-name">array</span>[] = {250, 178, 473, 128, 852, 367, 178, 542, 250};
        <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = <span class="org-keyword">sizeof</span>(array)/<span class="org-keyword">sizeof</span>(array[0]);

        print_array(<span class="org-string">"before sort_bubble flagged"</span>, array, n);
        sort_bubble(array, n);
        print_array(<span class="org-string">"after  sort_bubble flagged"</span>, array, n);

        <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6c1b9e1" class="outline-3">
<h3 id="org6c1b9e1"><span class="section-number-3">1.3</span> 选择排序</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org09e9d84" class="outline-4">
<h4 id="org09e9d84"><span class="section-number-4">1.3.1</span> 计算机编程艺术</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
直接选择排序: 适当重新安排记录R<sub>1</sub>, &#x2026;, R<sub>N</sub>；在完成排序后，它们的键码将是有序的K<sub>1</sub>&le;&#x2026;&le;K<sub>N</sub>。排序是以上边指出的方法为基础，但改为首选最大最大元素，紧接着选择第二个最大的，等等，这样做证明是更为方便的。
</p>

<p>
S1. [对j进行循环] 对 j=N, N-1, &#x2026;, 2执行步骤S2和S3；
S2. [找max(K<sub>1</sub>, &#x2026;, K<sub>j</sub>)] 查一遍K<sub>j</sub>, K<sub>j-1</sub>, &#x2026;, K<sub>1</sub> 以找出极大者，设它为K<sub>i</sub>，其中i尽可能地大；
S3. [同R<sub>j</sub>进行交换] 交换记录R<sub>i</sub>&harr;R<sub>j</sub>（现在诸记录R<sub>j</sub>, &#x2026;,
R<sub>N</sub>都处于它们的最后位置处）。
</p>
</div>
</div>

<div id="outline-container-org0c06d16" class="outline-4">
<h4 id="org0c06d16"><span class="section-number-4">1.3.2</span> C语言实现</h4>
<div class="outline-text-4" id="text-1-3-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">swap_int_nocheck</span>(<span class="org-type">int</span> *<span class="org-variable-name">a</span>, <span class="org-type">int</span> *<span class="org-variable-name">b</span>)
{
        <span class="org-type">int</span> <span class="org-variable-name">v</span> = *a;
        *a = *b;
        *b = v;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">sort_selection - sort algorithm by selecting</span>
<span class="org-comment"> * @array - starting pointer of integer array</span>
<span class="org-comment"> * @n - size of array @array</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">sort_selection</span>(<span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>)
{
        <span class="org-type">size_t</span> <span class="org-variable-name">i</span>, <span class="org-variable-name">j</span>, <span class="org-variable-name">t</span>;
        <span class="org-type">int</span> <span class="org-variable-name">v</span>;

        <span class="org-keyword">for</span> (i = 0; i &lt; n; ++i) {
                v = array[i];
                <span class="org-keyword">for</span> (j = i+1; j &lt; n; ++j) {
                        <span class="org-keyword">if</span> (v &gt; array[j]) {
                                v = array[j];
                                t = j;
                        }
                }

                <span class="org-comment-delimiter">/* </span><span class="org-comment">@array[t] is the maximum </span><span class="org-comment-delimiter">*/</span>
                <span class="org-keyword">if</span> (v != array[i]) {
                        swap_int_nocheck(array+i, array+t);
                }
        }
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">print_array</span>(<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">str</span>, <span class="org-keyword">const</span> <span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>)
{
        <span class="org-type">size_t</span> <span class="org-variable-name">i</span>;

        printf(<span class="org-string">"%s:"</span>, str);
        <span class="org-keyword">for</span> (i = 0; i &lt; n; ++i) {
                printf(<span class="org-string">" %d"</span>, array[i]);
        }
        printf(<span class="org-string">"\n"</span>);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[argc])
{
        <span class="org-type">int</span> <span class="org-variable-name">array</span>[] = {250, 178, 473, 128, 852, 367, 178, 542, 250};
        <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = <span class="org-keyword">sizeof</span>(array)/<span class="org-keyword">sizeof</span>(array[0]);

        print_array(<span class="org-string">"before sort_selection"</span>, array, n);
        sort_selection(array, n);
        print_array(<span class="org-string">"after  sort_selection"</span>, array, n);

        <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgec0475b" class="outline-3">
<h3 id="orgec0475b"><span class="section-number-3">1.4</span> 合并排序</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org5c60642" class="outline-4">
<h4 id="org5c60642"><span class="section-number-4">1.4.1</span> 计算机编程艺术</h4>
<div class="outline-text-4" id="text-1-4-1">
</div>
<div id="outline-container-orgc2c9d8f" class="outline-5">
<h5 id="orgc2c9d8f"><span class="section-number-5">1.4.1.1</span> 有序文件两路合并</h5>
<div class="outline-text-5" id="text-1-4-1-1">
<p>
两路合并：本算法把有序文件x<sub>1</sub>&le;x<sub>2</sub>&le;&#x2026;&le;x<sub>m</sub>和
y<sub>1</sub>&le;y<sub>2</sub>&le;&#x2026;&le;y<sub>n</sub>合并成单一文件
z<sub>1</sub>&le;z<sub>2</sub>&le;&#x2026;&le;z<sub>m+n</sub>。
</p>

<p>
M1. [初始化] 置 i&larr;1, j&larr;1, k&larr;1；<br />
M2. [找较小者] 如果x<sub>i</sub>&le;y<sub>i</sub>，则转到步骤3，否则转到步骤5；<br />
M3. [输出x<sub>i</sub>] 置z<sub>k</sub>&larr;x<sub>i</sub>，k&larr;k+1，i&larr;i+1，如果i&le;m，返回M2；<br />
M4. [传送y<sub>j</sub>, &#x2026;, y<sub>n</sub>] 置(z<sub>k</sub>, &#x2026;, z<sub>m+n</sub>)&larr;(y<sub>j</sub>, &#x2026;,
y<sub>n</sub>)并终止此算法；
M5. [输出y<sub>j</sub>] 置z<sub>k</sub>&larr;y<sub>j</sub>，k&larr;k+1，j&larr;j+1，如果j&le;n，返回M2；<br />
M6. [传送x<sub>i</sub>, &#x2026;, x<sub>m</sub>] 置(z<sub>k</sub>, &#x2026;, z<sub>m+n</sub>)&larr;(x<sub>i</sub>, &#x2026;,
x<sub>m</sub>)并终止此算法。
</p>
</div>
</div>

<div id="outline-container-org5e8344c" class="outline-5">
<h5 id="org5e8344c"><span class="section-number-5">1.4.1.2</span> 自然的两路合并排序</h5>
<div class="outline-text-5" id="text-1-4-1-2">
<p>
自然的两路合并排序: 使用两个存储区域，对记录R<sub>1</sub>, &#x2026;, R<sub>N</sub>排序，
</p>
</div>
</div>
</div>

<div id="outline-container-orge7b5e36" class="outline-4">
<h4 id="orge7b5e36"><span class="section-number-4">1.4.2</span> C语言实现</h4>
<div class="outline-text-4" id="text-1-4-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;errno.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdlib.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">swap_int_nocheck</span>(<span class="org-type">int</span> *<span class="org-variable-name">a</span>, <span class="org-type">int</span> *<span class="org-variable-name">b</span>)
{
        <span class="org-type">int</span> <span class="org-variable-name">v</span> = *a;
        *a = *b;
        *b = v;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">sort_merge - sort algorithm by merging</span>
<span class="org-comment"> * @array - starting pointer of integer array</span>
<span class="org-comment"> * @n - size of array @array</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">sort_merge</span>(<span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>)
{
        <span class="org-type">size_t</span> <span class="org-variable-name">i</span>, <span class="org-variable-name">j</span>, <span class="org-variable-name">t</span>;
        <span class="org-type">int</span> <span class="org-variable-name">v</span>, *<span class="org-variable-name">dest</span>, *<span class="org-variable-name">a</span>, *<span class="org-variable-name">b</span>;

        dest = malloc(<span class="org-keyword">sizeof</span>(*dest)*n);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>dest) {
                fprintf(stderr, <span class="org-string">"could not alloc mem for merge\n"</span>);
                <span class="org-keyword">return</span> ENOMEM;
        }

        <span class="org-keyword">for</span> (i = 0; i &lt; n; ++i) {
                v = array[i];
                <span class="org-keyword">for</span> (j = i+1; j &lt; n; ++j) {
                        <span class="org-keyword">if</span> (v &gt; array[j]) {
                                v = array[j];
                                t = j;
                        }
                }

                <span class="org-comment-delimiter">/* </span><span class="org-comment">@array[t] is the maximum </span><span class="org-comment-delimiter">*/</span>
                <span class="org-keyword">if</span> (v != array[i]) {
                        swap_int_nocheck(array+i, array+t);
                }
        }
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">print_array</span>(<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">str</span>, <span class="org-keyword">const</span> <span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>)
{
        <span class="org-type">size_t</span> <span class="org-variable-name">i</span>;

        printf(<span class="org-string">"%s:"</span>, str);
        <span class="org-keyword">for</span> (i = 0; i &lt; n; ++i) {
                printf(<span class="org-string">" %d"</span>, array[i]);
        }
        printf(<span class="org-string">"\n"</span>);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[argc])
{
        <span class="org-type">int</span> <span class="org-variable-name">array</span>[] = {250, 178, 473, 128, 852, 367, 178, 542, 250};
        <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = <span class="org-keyword">sizeof</span>(array)/<span class="org-keyword">sizeof</span>(array[0]);

        print_array(<span class="org-string">"before sort_merge"</span>, array, n);
        sort_merge(array, n);
        print_array(<span class="org-string">"after  sort_merge"</span>, array, n);

        <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6827239" class="outline-3">
<h3 id="org6827239"><span class="section-number-3">1.5</span> 快速排序</h3>
</div>
<div id="outline-container-org67c0776" class="outline-3">
<h3 id="org67c0776"><span class="section-number-3">1.6</span> 希尔排序</h3>
</div>
<div id="outline-container-org9a3e2a5" class="outline-3">
<h3 id="org9a3e2a5"><span class="section-number-3">1.7</span> 堆排序</h3>
</div>
<div id="outline-container-orgb15a273" class="outline-3">
<h3 id="orgb15a273"><span class="section-number-3">1.8</span> 桶排序</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread" class="disqus container"></div>
<script>
  var disqus_config = function () {
    this.page.url = 'http://ycode.org/blogs/algos-sort.html';
    this.page.identifier = 'algos-sort.html';
  };

  (function() {
    var d = document, s = d.createElement('script');
    s.src = 'https://yanyg.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<div class="copyright">
2012-2020 Copyright&copy; <i> YANYG - Powered by Emacs Orgmode</i>
</div>
</div>
</body>
</html>
