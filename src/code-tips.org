#+TITLE: 代码阅读笔记
#+INCLUDE: export-notes.org

* glibc
** definitions
*** =__THROW=
glibc/malloc/malloc.h中malloc函数声明如下：
#+BEGIN_SRC C
/* Allocate SIZE bytes of memory.  */
extern void *malloc (size_t __size) __THROW __attribute_malloc__ __wur;
#+END_SRC
malloc是熟悉的。什么是 =__THROW= 和 =__wur= ？__THROW是一个针对GCC 3.3以上版本，
以及C++的定义。

GCC 3.3版本以上添加__attribute__ ((__nothrow__ __LEAF))，通知编译器一个函数不能
抛出异常。绝大多数的C标准库函数不抛出异常。其中一个例外是使用函数指针作为参数的
函数，例如qsort和bsearch。单纯C语言程序中此属性时没有作用。在C++中调用C代码时，
编译器可基于此做优化。[[https://stackoverflow.com/questions/24882645/gcc-what-is-attribute-nothrow-used-for][Stackoverflow]]有这个问题的讨论。

GCC手册关于nothrow说明如下：
#+BEGIN_QUOTE
The nothrow attribute is used to inform the compiler that a function cannot
throw an exception. For example, most functions in the standard C library can
be guaranteed not to throw an exception with the notable exceptions of qsort
and bsearch that take function pointer arguments.

-- \\
Using the GCC Compiler Collection,\\
Chapter 6, 6.31 Declaring Attributes of Functions
#+END_QUOTE

misc/cdefs.h定义如下：
#+BEGIN_SRC C
/* GCC can always grok prototypes.  For C++ programs we add throw()
   to help it optimize the function calls.  But this works only with
   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
   as non-throwing using a function attribute since programs can use
   the -fexceptions options for C code as well.  */
# if !defined __cplusplus && __GNUC_PREREQ (3, 3)
#  define __THROW	__attribute__ ((__nothrow__ __LEAF))
#  define __THROWNL	__attribute__ ((__nothrow__))
#  define __NTH(fct)	__attribute__ ((__nothrow__ __LEAF)) fct
# else
#  if defined __cplusplus && __GNUC_PREREQ (2,8)
#   define __THROW	throw ()
#   define __THROWNL	throw ()
#   define __NTH(fct)	__LEAF_ATTR fct throw ()
#  else
#   define __THROW
#   define __THROWNL
#   define __NTH(fct)	fct
#  endif
# endif
#+END_SRC
*** =__leaf__=
leaf属性仅用于加速编译器链接，没什么边界效果，可忽略不管。

GCC 手册说明：
#+BEGIN_QUOTE
Calls to external functions with this attribute must return to the current
compilation unit only by return or by exception handling. In particular, leaf
functions are not allowed to call callback function passed to it from the
current compilation unit or directly call functions exported by the unit or
longjmp into the unit. Leaf function might still call functions from other
compilation units and thus they are not necessarily leaf in the sense that they
contain no function calls at all.

The attribute is intended for library functions to improve dataﬂow analysis.
The compiler takes the hint that any data not escaping the current compilation
unit can not be used or modifed by the leaf function. For example, the sin
function is a leaf function, but qsort is not.

Note that leaf functions might invoke signals and signal handlers might be
defned in the current compilation unit and use static variables. The only
compliant way to write such a signal handler is to declare such variables
volatile.

The attribute has no eﬀect on functions defned within the current compilation
unit. This is to allow easy merging of multiple compilation units into one, for
example, by using the link-time optimization. For this reason the attribute is
not allowed on types to annotate indirect calls.

-- \\
Using the GCC Compiler Collection,\\
Chapter 6, 6.31 Declaring Attributes of Functions
#+END_QUOTE
*** =__wul=
__wur是 =__attribute_warn_unused_result__= 缩写，关联GCC属性warn_unused_result。
调用设置此属性的函数时，如果不使用其返回值，会发出警告。
#+BEGIN_SRC C
  extern int func() __attribute__((warn_unused_result));
  int func()
  {
          return 0;
  }

  int main()
  {
          func();
          return 0;
  }
#+END_SRC

编译时有返回值未使用的警告：
#+BEGIN_QUOTE
wur.c:9:15: warning: ignoring return value of ‘func’, declared with attribute warn_unused_result [-Wunused-result]
           func();
               ^
#+END_QUOTE
