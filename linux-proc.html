<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
<head>
<!-- 2018-03-22 Thu 23:51 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Linux Proc Filesystem/Linux Proc文件系统</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="yanyg" />
<link rel="stylesheet" type="text/css" href="css/htmlize.css" />
<link rel="stylesheet" type="text/css" href="css/readtheorg.css" />
<script type="text/javascript" src="js/jquery-3.2.1.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="js/readtheorg.js"></script>
<link rel="stylesheet" type="text/css" href="css/htmlize.css" />
<link rel="stylesheet" type="text/css" href="css/readtheorg.css" />
<script type="text/javascript" src="js/jquery-3.2.1.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Linux Proc Filesystem/Linux Proc文件系统</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge4d2e6d">1. 介绍</a></li>
<li><a href="#org676a4f9">2. 分类描述</a>
<ul>
<li><a href="#org695289a">2.1. 内存相关</a></li>
</ul>
</li>
<li><a href="#org265281a">3. 清单化呈现(字母顺序排序)</a>
<ul>
<li><a href="#buddyinfo">3.1. proc/buddyinfo</a></li>
<li><a href="#org622e0c6">3.2. proc/cgroups</a></li>
<li><a href="#org6006b3a">3.3. proc/consoles</a></li>
<li><a href="#org5edc631">3.4. proc/cpuinfo</a></li>
<li><a href="#orgb4150db">3.5. proc/crypto</a></li>
<li><a href="#orgb5458a8">3.6. proc/devices</a></li>
<li><a href="#orgdeab8b9">3.7. proc/diskstats</a></li>
<li><a href="#org9c7cf0e">3.8. proc/dma</a></li>
<li><a href="#org5512de8">3.9. proc/execdomains</a></li>
<li><a href="#org514fc33">3.10. proc/fb</a></li>
<li><a href="#orgba92b80">3.11. proc/filesystems</a></li>
<li><a href="#org5696bbd">3.12. proc/fs</a></li>
<li><a href="#orgb2cb08a">3.13. proc/interrups</a></li>
<li><a href="#org5833bca">3.14. proc/&lt;pid&gt;</a>
<ul>
<li><a href="#org7880f0c">3.14.1. proc/&lt;pid&gt;/oom_adj</a></li>
<li><a href="#orgca662c6">3.14.2. proc/&lt;pid&gt;/oom_score</a></li>
<li><a href="#org7fbb3fb">3.14.3. proc/&lt;pid&gt;/oom_score_adj</a></li>
</ul>
</li>
<li><a href="#orgdb8fb5e">3.15. proc/self</a></li>
<li><a href="#orge9762eb">3.16. oom_score</a></li>
</ul>
</li>
<li><a href="#orgbe5dfea">4. 内核实现</a></li>
<li><a href="#orgc64916e">5. 参考资料</a></li>
</ul>
</div>
</div>

<div id="outline-container-orge4d2e6d" class="outline-2">
<h2 id="orge4d2e6d"><span class="section-number-2">1</span> 介绍</h2>
<div class="outline-text-2" id="text-1">
<p>
proc虚拟文件系统提供用户态与内核态数据交互的方式，一般挂载在/proc，由initrd启动初始化时挂载。proc下绝大多数文件用以导出内核信息，但也有部分允许修改，这些改变一般用于控制内核模块的功能或行为。
</p>
</div>
</div>

<div id="outline-container-org676a4f9" class="outline-2">
<h2 id="org676a4f9"><span class="section-number-2">2</span> 分类描述</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org695289a" class="outline-3">
<h3 id="org695289a"><span class="section-number-3">2.1</span> 内存相关</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li><a href="#buddyinfo">proc/buddyinfo</a></li>
<li>/proc/slabinfo</li>
<li>/proc/meminfo</li>
<li>/proc/iomem</li>
<li>/proc/ioports</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org265281a" class="outline-2">
<h2 id="org265281a"><span class="section-number-2">3</span> 清单化呈现(字母顺序排序)</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org84771bc" class="outline-3">
<h3 id="buddyinfo"><a id="org84771bc"></a><span class="section-number-3">3.1</span> proc/buddyinfo</h3>
<div class="outline-text-3" id="text-buddyinfo">
<p>
buddyinfo的内容是Linux系统伙伴管理系统的内存呈现，10列分别表示2<sup>nil</sup>0至2^10{} PAGE
内存数量。如下是某系统读取到的内容示例：
</p>
<div class="org-src-container">
<pre class="src src-sh">~$ cat /proc/buddyinfo
Node 0, zone      DMA      1      1      1      0      2      1      1      0      1      1      3
Node 0, zone    DMA32    645    775    517    199     83      7     20     93     50      8    294
Node 0, zone   Normal    143    100     14     14      5      1      3      2      1      2      0
</pre>
</div>

<p>
内核代码<a href="https://elixir.bootlin.com/linux/v4.15.4/source/mm/vmstat.c#L1539">linux/mm/vmstat.c</a>:
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">buddyinfo_file_operations</span> = {
        .open           = fragmentation_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = seq_release,
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org622e0c6" class="outline-3">
<h3 id="org622e0c6"><span class="section-number-3">3.2</span> proc/cgroups</h3>
<div class="outline-text-3" id="text-3-2">
<p>
cgroups(Control Groups)是Linux资源管理的特性，实现分级分组进行资源限制和监控。通过伪文件系统cgroupfs提供交互接口。\(man 7 cgroups\)获取详细信息。
</p>

<p>
内核代码<a href="https://elixir.bootlin.com/linux/v4.15.4/source/fs/proc/cmdline.c">fs/proc/cmdline.c</a>:
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">cmdline_proc_show</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">m</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
        seq_printf(m, <span class="org-string">"%s\n"</span>, saved_command_line);
        <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">cmdline_proc_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
        <span class="org-keyword">return</span> single_open(file, cmdline_proc_show, <span class="org-constant">NULL</span>);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">cmdline_proc_fops</span> = {
        .open           = cmdline_proc_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = single_release,
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> proc_cmdline_init(<span class="org-type">void</span>)
{
        proc_create(<span class="org-string">"cmdline"</span>, 0, <span class="org-constant">NULL</span>, &amp;cmdline_proc_fops);
        <span class="org-keyword">return</span> 0;
}
<span class="org-function-name">fs_initcall</span>(proc_cmdline_init);
</pre>
</div>
</div>
</div>

<div id="outline-container-org6006b3a" class="outline-3">
<h3 id="org6006b3a"><span class="section-number-3">3.3</span> proc/consoles</h3>
<div class="outline-text-3" id="text-3-3">
<p>
consoles显示系统中所有可见的console信息。
</p>

<p>
内核代码<a href="https://elixir.bootlin.com/linux/v4.15.4/source/fs/proc/consoles.c">fs/proc/consoles.c</a>:
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">seq_operations</span> <span class="org-variable-name">consoles_op</span> = {
        .start  = c_start,
        .next   = c_next,
        .stop   = c_stop,
        .show   = show_console_dev
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">consoles_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
        <span class="org-keyword">return</span> seq_open(file, &amp;consoles_op);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">proc_consoles_operations</span> = {
        .open           = consoles_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = seq_release,
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> proc_consoles_init(<span class="org-type">void</span>)
{
        proc_create(<span class="org-string">"consoles"</span>, 0, <span class="org-constant">NULL</span>, &amp;proc_consoles_operations);
        <span class="org-keyword">return</span> 0;
}
<span class="org-function-name">fs_initcall</span>(proc_consoles_init);
</pre>
</div>
</div>
</div>

<div id="outline-container-org5edc631" class="outline-3">
<h3 id="org5edc631"><span class="section-number-3">3.4</span> proc/cpuinfo</h3>
<div class="outline-text-3" id="text-3-4">
<p>
cpuinfo显示CPU相关信息：
</p>
<div class="org-src-container">
<pre class="src src-sh">~$ cat /proc/cpuinfo
processor       : 0
vendor_id       : GenuineIntel
cpu family      : 6
model           : 60
model name      : Intel(R) Core(TM) i5-4570 CPU @ 3.20GHz
stepping        : 3
microcode       : 0x1c
cpu MHz         : 3200.390
cache size      : 6144 KB
physical id     : 0
siblings        : 4
core id         : 0
cpu cores       : 4
apicid          : 0
initial apicid  : 0
fpu             : yes
fpu_exception   : yes
cpuid level     : 13
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall n
x pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf eagerfpu pni pclmulqdq dtes64 monitor ds_cpl
vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm epb t
pr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid xsaveopt dtherm ida arat pln pts
bugs            :
bogomips        : 6384.87
clflush size    : 64
cache_alignment : 64
address sizes   : 39 bits physical, 48 bits virtual
power management:

processor       : 1
vendor_id       : GenuineIntel
cpu family      : 6
model           : 60
model name      : Intel(R) Core(TM) i5-4570 CPU @ 3.20GHz
stepping        : 3
...
</pre>
</div>

<p>
内核代码由平台无关<a href="https://elixir.bootlin.com/linux/v4.15.4/source/fs/proc/cpuinfo.c">fs/proc/cpuinfo.c</a>和平台相关(<a href="https://elixir.bootlin.com/linux/v4.15.4/source/arch/x86/kernel/cpu/proc.c#L162">arch/x86/kernel/cpu/proc.c</a>)组成：
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">cpuinfo_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
        arch_freq_prepare_all();
        <span class="org-keyword">return</span> seq_open(file, &amp;cpuinfo_op);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">proc_cpuinfo_operations</span> = {
        .open           = cpuinfo_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = seq_release,
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> proc_cpuinfo_init(<span class="org-type">void</span>)
{
        proc_create(<span class="org-string">"cpuinfo"</span>, 0, <span class="org-constant">NULL</span>, &amp;proc_cpuinfo_operations);
        <span class="org-keyword">return</span> 0;
}
<span class="org-function-name">fs_initcall</span>(proc_cpuinfo_init);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb4150db" class="outline-3">
<h3 id="orgb4150db"><span class="section-number-3">3.5</span> proc/crypto</h3>
<div class="outline-text-3" id="text-3-5">
<p>
crypto显示系统支持的密码算法。部分内容示例如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">~$ cat /proc/crypto
name         : crct10dif
driver       : crct10dif-pclmul
module       : crct10dif_pclmul
priority     : 200
refcnt       : 1
selftest     : passed
internal     : no
<span class="org-builtin">type</span>         : shash
blocksize    : 1
digestsize   : 2
...
name         : sha1
driver       : sha1-generic
module       : kernel
priority     : 0
refcnt       : 1
selftest     : passed
internal     : no
<span class="org-builtin">type</span>         : shash
blocksize    : 64
digestsize   : 20
</pre>
</div>

<p>
内核代码<a href="https://elixir.bootlin.com/linux/v4.15.4/source/crypto/proc.c#L103">crypto/proc.c</a>:
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">seq_operations</span> <span class="org-variable-name">crypto_seq_ops</span> = {
        .start          = c_start,
        .next           = c_next,
        .stop           = c_stop,
        .show           = c_show
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">crypto_info_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
        <span class="org-keyword">return</span> seq_open(file, &amp;crypto_seq_ops);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">proc_crypto_ops</span> = {
        .open           = crypto_info_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = seq_release
};

<span class="org-type">void</span> <span class="org-function-name">__init</span> crypto_init_proc(<span class="org-type">void</span>)
{
        proc_create(<span class="org-string">"crypto"</span>, 0, <span class="org-constant">NULL</span>, &amp;proc_crypto_ops);
}

<span class="org-type">void</span> <span class="org-function-name">__exit</span> crypto_exit_proc(<span class="org-type">void</span>)
{
        remove_proc_entry(<span class="org-string">"crypto"</span>, <span class="org-constant">NULL</span>);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb5458a8" class="outline-3">
<h3 id="orgb5458a8"><span class="section-number-3">3.6</span> proc/devices</h3>
<div class="outline-text-3" id="text-3-6">
<p>
devices显示字符设备和块设备主设备号。如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">~$ cat /proc/devices
Character devices:
  1 mem
  4 /dev/vc/0
  4 tty
  4 ttyS
  5 /dev/tty
  5 /dev/console
  5 /dev/ptmx
  6 lp
  7 vcs
 10 misc
 13 input
 21 sg
 29 fb
 81 video4linux
 99 ppdev
116 alsa
128 ptm
136 pts
180 usb
189 usb_device
216 rfcomm

...

253 tpm
254 gpiochip

Block devices:
259 blkext
  8 sd
 65 sd
 66 sd
 67 sd
 68 sd
 69 sd
 70 sd
 71 sd
128 sd
129 sd
130 sd
131 sd
</pre>
</div>

<p>
内核代码<a href="https://elixir.bootlin.com/linux/v4.15.4/source/fs/proc/devices.c">fs/proc/devices.c</a>:
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">seq_operations</span> <span class="org-variable-name">devinfo_ops</span> = {
        .start = devinfo_start,
        .next  = devinfo_next,
        .stop  = devinfo_stop,
        .show  = devinfo_show
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">devinfo_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filp</span>)
{
        <span class="org-keyword">return</span> seq_open(filp, &amp;devinfo_ops);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">proc_devinfo_operations</span> = {
        .open           = devinfo_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = seq_release,
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> proc_devices_init(<span class="org-type">void</span>)
{
        proc_create(<span class="org-string">"devices"</span>, 0, <span class="org-constant">NULL</span>, &amp;proc_devinfo_operations);
        <span class="org-keyword">return</span> 0;
}
<span class="org-function-name">fs_initcall</span>(proc_devices_init);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">devinfo_show</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">f</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
        <span class="org-type">int</span> <span class="org-variable-name">i</span> = *(<span class="org-type">loff_t</span> *) v;

        <span class="org-keyword">if</span> (i &lt; CHRDEV_MAJOR_MAX) {
                <span class="org-keyword">if</span> (i == 0)
                        seq_puts(f, <span class="org-string">"Character devices:\n"</span>);
                chrdev_show(f, i);
        }
<span class="org-preprocessor">#ifdef</span> CONFIG_BLOCK
        <span class="org-keyword">else</span> {
                i -= CHRDEV_MAJOR_MAX;
                <span class="org-keyword">if</span> (i == 0)
                        seq_puts(f, <span class="org-string">"\nBlock devices:\n"</span>);
                blkdev_show(f, i);
        }
<span class="org-preprocessor">#endif</span>
        <span class="org-keyword">return</span> 0;
}

<span class="org-type">void</span> <span class="org-function-name">chrdev_show</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">f</span>, <span class="org-type">off_t</span> <span class="org-variable-name">offset</span>)
{
        <span class="org-keyword">struct</span> <span class="org-type">char_device_struct</span> *<span class="org-variable-name">cd</span>;

        mutex_lock(&amp;chrdevs_lock);
        <span class="org-keyword">for</span> (cd = chrdevs[major_to_index(offset)]; cd; cd = cd-&gt;next) {
                <span class="org-keyword">if</span> (cd-&gt;major == offset)
                        seq_printf(f, <span class="org-string">"%3d %s\n"</span>, cd-&gt;major, cd-&gt;name);
        }
        mutex_unlock(&amp;chrdevs_lock);
}

<span class="org-type">void</span> <span class="org-function-name">blkdev_show</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">seqf</span>, <span class="org-type">off_t</span> <span class="org-variable-name">offset</span>)
{
        <span class="org-keyword">struct</span> <span class="org-type">blk_major_name</span> *<span class="org-variable-name">dp</span>;

        mutex_lock(&amp;block_class_lock);
        <span class="org-keyword">for</span> (dp = major_names[major_to_index(offset)]; dp; dp = dp-&gt;next)
                <span class="org-keyword">if</span> (dp-&gt;major == offset)
                        seq_printf(seqf, <span class="org-string">"%3d %s\n"</span>, dp-&gt;major, dp-&gt;name);
        mutex_unlock(&amp;block_class_lock);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdeab8b9" class="outline-3">
<h3 id="orgdeab8b9"><span class="section-number-3">3.7</span> proc/diskstats</h3>
<div class="outline-text-3" id="text-3-7">
<p>
diskstats显示disk统计信息。如下是示例，输出内容解析参考<a href="https://elixir.bootlin.com/linux/v4.15.4/source/Documentation/iostats.txt">Documentation/iostats.txt</a>：
</p>
<div class="org-src-container">
<pre class="src src-sh">cat /proc/diskstats
   8      16 sdb 476 0 37508 15096 0 0 0 0 0 2608 15096
   8      17 sdb1 50 0 4160 1780 0 0 0 0 0 1780 1780
   8      18 sdb2 48 0 4144 1400 0 0 0 0 0 1380 1400
   8      19 sdb3 48 0 4144 1952 0 0 0 0 0 1884 1952
   8      20 sdb4 2 0 4 176 0 0 0 0 0 176 176
   8      21 sdb5 46 0 4128 2588 0 0 0 0 0 1640 2588
   8      22 sdb6 46 0 4128 1052 0 0 0 0 0 1004 1052
   8      23 sdb7 48 0 4144 984 0 0 0 0 0 980 984
   8      24 sdb8 50 0 4160 2536 0 0 0 0 0 2016 2536
   8      25 sdb9 48 0 4144 1188 0 0 0 0 0 1188 1188
   8       0 sda 28874 1231 1655786 10164 6376 11927 340456 6204 0 5348 16352
   8       1 sda1 52 0 4176 24 0 0 0 0 0 16 24
   8       2 sda2 28795 1231 1649538 10136 6225 11927 340456 6068 0 5216 16188
</pre>
</div>

<p>
各列概要如下：
</p>
<div class="org-src-container">
<pre class="src src-text"> 1 - major number
 2 - minor mumber
 3 - device name
 4 - reads completed successfully
 5 - reads merged
 6 - sectors read
 7 - time spent reading (ms)
 8 - writes completed
 9 - writes merged
10 - sectors written
11 - time spent writing (ms)
12 - I/Os currently in progress
13 - time spent doing I/Os (ms)
14 - weighted time spent doing I/Os (ms)
</pre>
</div>

<p>
第4-14列说明如下：
</p>
<p class="verse">
Field  1 &#x2013; # of reads completed<br />
&#xa0;&#xa0;&#xa0;&#xa0;This is the total number of reads completed successfully.<br />
<br />
Field  2 &#x2013; # of reads merged, field 6 &#x2013; # of writes merged<br />
&#xa0;&#xa0;&#xa0;&#xa0;Reads and writes which are adjacent to each other may be merged for<br />
&#xa0;&#xa0;&#xa0;&#xa0;efficiency.  Thus two 4K reads may become one 8K read before it is<br />
&#xa0;&#xa0;&#xa0;&#xa0;ultimately handed to the disk, and so it will be counted (and queued)<br />
&#xa0;&#xa0;&#xa0;&#xa0;as only one I/O.  This field lets you know how often this was done.<br />
<br />
Field  3 &#x2013; # of sectors read<br />
&#xa0;&#xa0;&#xa0;&#xa0;This is the total number of sectors read successfully.<br />
<br />
Field  4 &#x2013; # of milliseconds spent reading<br />
&#xa0;&#xa0;&#xa0;&#xa0;This is the total number of milliseconds spent by all reads (as<br />
&#xa0;&#xa0;&#xa0;&#xa0;measured from __make_request() to end_that_request_last()).<br />
<br />
Field  5 &#x2013; # of writes completed<br />
&#xa0;&#xa0;&#xa0;&#xa0;This is the total number of writes completed successfully.<br />
<br />
Field  6 &#x2013; # of writes merged<br />
&#xa0;&#xa0;&#xa0;&#xa0;See the description of field 2.<br />
<br />
Field  7 &#x2013; # of sectors written<br />
&#xa0;&#xa0;&#xa0;&#xa0;This is the total number of sectors written successfully.<br />
<br />
Field  8 &#x2013; # of milliseconds spent writing<br />
&#xa0;&#xa0;&#xa0;&#xa0;This is the total number of milliseconds spent by all writes (as<br />
&#xa0;&#xa0;&#xa0;&#xa0;measured from __make_request() to end_that_request_last()).<br />
<br />
Field  9 &#x2013; # of I/Os currently in progress<br />
&#xa0;&#xa0;&#xa0;&#xa0;The only field that should go to zero. Incremented as requests are<br />
&#xa0;&#xa0;&#xa0;&#xa0;given to appropriate struct request_queue and decremented as they finish.<br />
<br />
Field 10 &#x2013; # of milliseconds spent doing I/Os<br />
&#xa0;&#xa0;&#xa0;&#xa0;This field increases so long as field 9 is nonzero.<br />
<br />
Field 11 &#x2013; weighted # of milliseconds spent doing I/Os<br />
&#xa0;&#xa0;&#xa0;&#xa0;This field is incremented at each I/O start, I/O completion, I/O<br />
&#xa0;&#xa0;&#xa0;&#xa0;merge, or read of these stats by the number of I/Os in progress<br />
&#xa0;&#xa0;&#xa0;&#xa0;(field 9) times the number of milliseconds spent doing I/O since the<br />
&#xa0;&#xa0;&#xa0;&#xa0;last update of this field.  This can provide an easy measure of both<br />
&#xa0;&#xa0;&#xa0;&#xa0;I/O completion time and the backlog that may be accumulating.<br />
</p>

<p>
内核代码<a href="https://elixir.bootlin.com/linux/v4.15.4/source/block/genhd.c#L1341">block/genhd.c</a>：
</p>
<div class="org-src-container">
<pre class="src src-C">
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">seq_operations</span> <span class="org-variable-name">diskstats_op</span> = {
        .start  = disk_seqf_start,
        .next   = disk_seqf_next,
        .stop   = disk_seqf_stop,
        .show   = diskstats_show
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">diskstats_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
        <span class="org-keyword">return</span> seq_open(file, &amp;diskstats_op);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">proc_diskstats_operations</span> = {
        .open           = diskstats_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = seq_release,
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> proc_genhd_init(<span class="org-type">void</span>)
{
        proc_create(<span class="org-string">"diskstats"</span>, 0, <span class="org-constant">NULL</span>, &amp;proc_diskstats_operations);
        proc_create(<span class="org-string">"partitions"</span>, 0, <span class="org-constant">NULL</span>, &amp;proc_partitions_operations);
        <span class="org-keyword">return</span> 0;
}
<span class="org-function-name">module_init</span>(proc_genhd_init);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">diskstats_show</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">seqf</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
        <span class="org-keyword">struct</span> <span class="org-type">gendisk</span> *<span class="org-variable-name">gp</span> = v;
        <span class="org-keyword">struct</span> <span class="org-type">disk_part_iter</span> <span class="org-variable-name">piter</span>;
        <span class="org-keyword">struct</span> <span class="org-type">hd_struct</span> *<span class="org-variable-name">hd</span>;
        <span class="org-type">char</span> <span class="org-variable-name">buf</span>[BDEVNAME_SIZE];
        <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">inflight</span>[2];
        <span class="org-type">int</span> <span class="org-variable-name">cpu</span>;

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">        if (&amp;disk_to_dev(gp)-&gt;kobj.entry == block_class.devices.next)</span>
<span class="org-comment">                seq_puts(seqf,  "major minor name"</span>
<span class="org-comment">                                "     rio rmerge rsect ruse wio wmerge "</span>
<span class="org-comment">                                "wsect wuse running use aveq"</span>
<span class="org-comment">                                "\n\n");</span>
<span class="org-comment">        </span><span class="org-comment-delimiter">*/</span>

        disk_part_iter_init(&amp;piter, gp, DISK_PITER_INCL_EMPTY_PART0);
        <span class="org-keyword">while</span> ((hd = disk_part_iter_next(&amp;piter))) {
                cpu = part_stat_lock();
                part_round_stats(gp-&gt;queue, cpu, hd);
                part_stat_unlock();
                part_in_flight(gp-&gt;queue, hd, inflight);
                seq_printf(seqf, <span class="org-string">"%4d %7d %s %lu %lu %lu "</span>
                           <span class="org-string">"%u %lu %lu %lu %u %u %u %u\n"</span>,
                           MAJOR(part_devt(hd)), MINOR(part_devt(hd)),
                           disk_name(gp, hd-&gt;partno, buf),
                           part_stat_read(hd, ios[READ]),
                           part_stat_read(hd, merges[READ]),
                           part_stat_read(hd, sectors[READ]),
                           jiffies_to_msecs(part_stat_read(hd, ticks[READ])),
                           part_stat_read(hd, ios[WRITE]),
                           part_stat_read(hd, merges[WRITE]),
                           part_stat_read(hd, sectors[WRITE]),
                           jiffies_to_msecs(part_stat_read(hd, ticks[WRITE])),
                           inflight[0],
                           jiffies_to_msecs(part_stat_read(hd, io_ticks)),
                           jiffies_to_msecs(part_stat_read(hd, time_in_queue))
                        );
        }
        disk_part_iter_exit(&amp;piter);

        <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9c7cf0e" class="outline-3">
<h3 id="org9c7cf0e"><span class="section-number-3">3.8</span> proc/dma</h3>
<div class="outline-text-3" id="text-3-8">
<p>
This is a list of the registered ISA DMA (direct memory access) channels in use.
</p>
<div class="org-src-container">
<pre class="src src-sh">~$ cat /proc/dma
 4: cascade
</pre>
</div>

<p>
内核代码<a href="https://elixir.bootlin.com/linux/v4.15.4/source/kernel/dma.c">kernel/dma.c</a>：
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">proc_dma_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
        <span class="org-keyword">return</span> single_open(file, proc_dma_show, <span class="org-constant">NULL</span>);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">proc_dma_operations</span> = {
        .open           = proc_dma_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = single_release,
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> proc_dma_init(<span class="org-type">void</span>)
{
        proc_create(<span class="org-string">"dma"</span>, 0, <span class="org-constant">NULL</span>, &amp;proc_dma_operations);
        <span class="org-keyword">return</span> 0;
}

<span class="org-function-name">__initcall</span>(proc_dma_init);

<span class="org-preprocessor">#ifdef</span> MAX_DMA_CHANNELS
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">proc_dma_show</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">m</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
        <span class="org-type">int</span> <span class="org-variable-name">i</span>;

        <span class="org-keyword">for</span> (i = 0 ; i &lt; MAX_DMA_CHANNELS ; i++) {
                <span class="org-keyword">if</span> (dma_chan_busy[i].lock) {
                        seq_printf(m, <span class="org-string">"%2d: %s\n"</span>, i,
                                   dma_chan_busy[i].device_id);
                }
        }
        <span class="org-keyword">return</span> 0;
}
<span class="org-preprocessor">#else</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">proc_dma_show</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">m</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
        seq_puts(m, <span class="org-string">"No DMA\n"</span>);
        <span class="org-keyword">return</span> 0;
}
<span class="org-preprocessor">#endif</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">MAX_DMA_CHANNELS </span><span class="org-comment-delimiter">*/</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5512de8" class="outline-3">
<h3 id="org5512de8"><span class="section-number-3">3.9</span> proc/execdomains</h3>
<div class="outline-text-3" id="text-3-9">
<p>
execdomains显示当前支持的可执行文件domains(ABI)。当前总是显示Linux [kernel]：
</p>
<div class="org-src-container">
<pre class="src src-sh">cat /proc/execdomains
0-0     Linux                   [kernel]
</pre>
</div>

<p>
内核代码<a href="https://elixir.bootlin.com/linux/v4.15.4/source/kernel/exec_domain.c">kernel/exec_domain.c</a>：
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#ifdef</span> CONFIG_PROC_FS
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">execdomains_proc_show</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">m</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
        seq_puts(m, <span class="org-string">"0-0\tLinux           \t[kernel]\n"</span>);
        <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">execdomains_proc_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
        <span class="org-keyword">return</span> single_open(file, execdomains_proc_show, <span class="org-constant">NULL</span>);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">execdomains_proc_fops</span> = {
        .open           = execdomains_proc_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = single_release,
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> proc_execdomains_init(<span class="org-type">void</span>)
{
        proc_create(<span class="org-string">"execdomains"</span>, 0, <span class="org-constant">NULL</span>, &amp;execdomains_proc_fops);
        <span class="org-keyword">return</span> 0;
}
<span class="org-function-name">module_init</span>(proc_execdomains_init);
<span class="org-preprocessor">#endif</span>

<span class="org-function-name">SYSCALL_DEFINE1</span>(personality, <span class="org-type">unsigned</span> <span class="org-type">int</span>, personality)
{
        <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">old</span> = current-&gt;personality;

        <span class="org-keyword">if</span> (personality != 0xffffffff)
                set_personality(personality);

        <span class="org-keyword">return</span> old;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org514fc33" class="outline-3">
<h3 id="org514fc33"><span class="section-number-3">3.10</span> proc/fb</h3>
<div class="outline-text-3" id="text-3-10">
<p>
fb(frame buffer)显示当前系统fb信息：
</p>
<div class="org-src-container">
<pre class="src src-sh">~$ cat /proc/fb
0 inteldrmfb
</pre>
</div>

<p>
内核代码<a href="https://elixir.bootlin.com/linux/v4.15.4/source/drivers/video/fbdev/core/fbmem.c">drivers/video/fbdev/core/fbmem.c</a>：
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">fb_seq_show</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">m</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
        <span class="org-type">int</span> <span class="org-variable-name">i</span> = *(<span class="org-type">loff_t</span> *)v;
        <span class="org-keyword">struct</span> <span class="org-type">fb_info</span> *<span class="org-variable-name">fi</span> = registered_fb[i];

        <span class="org-keyword">if</span> (fi)
                seq_printf(m, <span class="org-string">"%d %s\n"</span>, fi-&gt;node, fi-&gt;fix.id);
        <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">seq_operations</span> <span class="org-variable-name">proc_fb_seq_ops</span> = {
        .start  = fb_seq_start,
        .next   = fb_seq_next,
        .stop   = fb_seq_stop,
        .show   = fb_seq_show,
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">proc_fb_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
        <span class="org-keyword">return</span> seq_open(file, &amp;proc_fb_seq_ops);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">fb_proc_fops</span> = {
        .owner          = THIS_MODULE,
        .open           = proc_fb_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = seq_release,
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgba92b80" class="outline-3">
<h3 id="orgba92b80"><span class="section-number-3">3.11</span> proc/filesystems</h3>
<div class="outline-text-3" id="text-3-11">
<p>
filesystems列举当前支持的文件系统类型：
</p>
<div class="org-src-container">
<pre class="src src-sh">~$ cat /proc/filesystems
nodev   sysfs
nodev   rootfs
nodev   ramfs
nodev   bdev
nodev   proc
nodev   cpuset
nodev   cgroup
nodev   cgroup2
nodev   tmpfs
nodev   devtmpfs
nodev   debugfs
nodev   tracefs
nodev   securityfs
nodev   sockfs
nodev   bpf
nodev   pipefs
nodev   hugetlbfs
nodev   devpts
nodev   pstore
nodev   mqueue
        ext3
        ext2
        ext4
nodev   autofs
nodev   binfmt_misc
        fuseblk
nodev   fuse
nodev   fusectl
</pre>
</div>

<p>
内核代码<a href="https://elixir.bootlin.com/linux/v4.15.4/source/fs/filesystems.c">fs/filesystems.c</a>：
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">filesystems_proc_show</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">m</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
        <span class="org-keyword">struct</span> <span class="org-type">file_system_type</span> * <span class="org-variable-name">tmp</span>;

        read_lock(&amp;file_systems_lock);
        tmp = file_systems;
        <span class="org-keyword">while</span> (tmp) {
                seq_printf(m, <span class="org-string">"%s\t%s\n"</span>,
                        (tmp-&gt;fs_flags &amp; FS_REQUIRES_DEV) ? <span class="org-string">""</span> : <span class="org-string">"nodev"</span>,
                        tmp-&gt;name);
                tmp = tmp-&gt;next;
        }
        read_unlock(&amp;file_systems_lock);
        <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">filesystems_proc_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
        <span class="org-keyword">return</span> single_open(file, filesystems_proc_show, <span class="org-constant">NULL</span>);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">filesystems_proc_fops</span> = {
        .open           = filesystems_proc_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = single_release,
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> proc_filesystems_init(<span class="org-type">void</span>)
{
        proc_create(<span class="org-string">"filesystems"</span>, 0, <span class="org-constant">NULL</span>, &amp;filesystems_proc_fops);
        <span class="org-keyword">return</span> 0;
}
<span class="org-function-name">module_init</span>(proc_filesystems_init);
</pre>
</div>
</div>
</div>

<div id="outline-container-org5696bbd" class="outline-3">
<h3 id="org5696bbd"><span class="section-number-3">3.12</span> proc/fs</h3>
<div class="outline-text-3" id="text-3-12">
<p>
fs目录下包含子目录，每个子目录是一种当前正在使用的文件系统名称（比如ext4），每个文件系统子目录下二级子目录是每个挂载的块设备（比如sda2），其下文件是其属性。
</p>

<p>
proc/fs是由<a href="https://elixir.bootlin.com/linux/v4.15.4/source/fs/proc/root.c#L144">fs/proc/root.c</a>创建的：
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">void</span> <span class="org-function-name">__init</span> proc_root_init(<span class="org-type">void</span>)
{
        <span class="org-type">int</span> <span class="org-variable-name">err</span>;

        proc_init_inodecache();
        set_proc_pid_nlink();
        err = register_filesystem(&amp;proc_fs_type);
        <span class="org-keyword">if</span> (err)
                <span class="org-keyword">return</span>;

        proc_self_init();
        proc_thread_self_init();
        proc_symlink(<span class="org-string">"mounts"</span>, <span class="org-constant">NULL</span>, <span class="org-string">"self/mounts"</span>);

        proc_net_init();

<span class="org-preprocessor">#ifdef</span> CONFIG_SYSVIPC
        proc_mkdir(<span class="org-string">"sysvipc"</span>, <span class="org-constant">NULL</span>);
<span class="org-preprocessor">#endif</span>
        proc_mkdir(<span class="org-string">"fs"</span>, <span class="org-constant">NULL</span>);
        proc_mkdir(<span class="org-string">"driver"</span>, <span class="org-constant">NULL</span>);
        proc_create_mount_point(<span class="org-string">"fs/nfsd"</span>); <span class="org-comment-delimiter">/* </span><span class="org-comment">somewhere for the nfsd filesystem to be mounted </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#if</span> <span class="org-preprocessor">defined</span>(CONFIG_SUN_OPENPROMFS) || <span class="org-preprocessor">defined</span>(CONFIG_SUN_OPENPROMFS_MODULE)
        <span class="org-comment-delimiter">/* </span><span class="org-comment">just give it a mountpoint </span><span class="org-comment-delimiter">*/</span>
        proc_create_mount_point(<span class="org-string">"openprom"</span>);
<span class="org-preprocessor">#endif</span>
        proc_tty_init();
        proc_mkdir(<span class="org-string">"bus"</span>, <span class="org-constant">NULL</span>);
        proc_sys_init();
}
</pre>
</div>

<p>
每个子目录是由不同的文件系统创建的，比如ext4：
<a href="https://elixir.bootlin.com/linux/v4.15.4/source/fs/ext4/sysfs.c">fs/ext4/sysfs.c</a>：
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">char</span> <span class="org-variable-name">proc_dirname</span>[] = <span class="org-string">"fs/ext4"</span>;
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">proc_dir_entry</span> *<span class="org-variable-name">ext4_proc_root</span>;

<span class="org-type">int</span> <span class="org-function-name">__init</span> ext4_init_sysfs(<span class="org-type">void</span>)
{
        <span class="org-type">int</span> <span class="org-variable-name">ret</span>;

        kobject_set_name(&amp;ext4_kset.kobj, <span class="org-string">"ext4"</span>);
        ext4_kset.kobj.parent = fs_kobj;
        ret = kset_register(&amp;ext4_kset);
        <span class="org-keyword">if</span> (ret)
                <span class="org-keyword">return</span> ret;

        ret = kobject_init_and_add(&amp;ext4_feat, &amp;ext4_feat_ktype,
                                   <span class="org-constant">NULL</span>, <span class="org-string">"features"</span>);
        <span class="org-keyword">if</span> (ret)
                kset_unregister(&amp;ext4_kset);
        <span class="org-keyword">else</span>
                ext4_proc_root = proc_mkdir(proc_dirname, <span class="org-constant">NULL</span>);
        <span class="org-keyword">return</span> ret;
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">ext4_proc_files</span> {
        <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">name</span>;
        <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> *<span class="org-variable-name">fops</span>;
} <span class="org-variable-name">proc_files</span>[] = {
        PROC_FILE_LIST(options),
        PROC_FILE_LIST(es_shrinker_info),
        PROC_FILE_LIST(mb_groups),
        { <span class="org-constant">NULL</span>, <span class="org-constant">NULL</span> },
};

<span class="org-type">int</span> <span class="org-function-name">ext4_register_sysfs</span>(<span class="org-keyword">struct</span> <span class="org-type">super_block</span> *<span class="org-variable-name">sb</span>)
{
        <span class="org-keyword">struct</span> <span class="org-type">ext4_sb_info</span> *<span class="org-variable-name">sbi</span> = EXT4_SB(sb);
        <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">ext4_proc_files</span> *<span class="org-variable-name">p</span>;
        <span class="org-type">int</span> <span class="org-variable-name">err</span>;

        sbi-&gt;s_kobj.kset = &amp;ext4_kset;
        init_completion(&amp;sbi-&gt;s_kobj_unregister);
        err = kobject_init_and_add(&amp;sbi-&gt;s_kobj, &amp;ext4_sb_ktype, <span class="org-constant">NULL</span>,
                                   <span class="org-string">"%s"</span>, sb-&gt;s_id);
        <span class="org-keyword">if</span> (err)
                <span class="org-keyword">return</span> err;

        <span class="org-keyword">if</span> (ext4_proc_root)
                sbi-&gt;s_proc = proc_mkdir(sb-&gt;s_id, ext4_proc_root);

        <span class="org-keyword">if</span> (sbi-&gt;s_proc) {
                <span class="org-keyword">for</span> (p = proc_files; p-&gt;name; p++)
                        proc_create_data(p-&gt;name, S_IRUGO, sbi-&gt;s_proc,
                                         p-&gt;fops, sb);
        }
        <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb2cb08a" class="outline-3">
<h3 id="orgb2cb08a"><span class="section-number-3">3.13</span> proc/interrups</h3>
<div class="outline-text-3" id="text-3-13">
<p>
interrupts显示每CPU每设备的中断数，此文件信息可用来分析中断是否均衡：
</p>
<div class="org-src-container">
<pre class="src src-sh">~$ cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3
  0:         18          0          0          0  IR-IO-APIC   2-edge      timer
  1:          3          1          1          8  IR-IO-APIC   1-edge      i8042
  8:          1          0          0          0  IR-IO-APIC   8-edge      rtc0
  9:       1076       2273        812        836  IR-IO-APIC   9-fasteoi   acpi
 12:         42        475         34         51  IR-IO-APIC  12-edge      i8042
 16:          2         23          2          2  IR-IO-APIC  16-fasteoi   ehci_hcd:usb1
 18:          0          0          1          0  IR-IO-APIC  18-fasteoi   i801_smbus
 23:          3         28          0          2  IR-IO-APIC  23-fasteoi   ehci_hcd:usb2
 24:          0          0          0          0  DMAR-MSI   0-edge      dmar0
 25:          0          0          0          0  DMAR-MSI   1-edge      dmar1
 28:         17          1          3          1  IR-PCI-MSI 1572864-edge      rtsx_pci
 29:        160       1281        141        110  IR-PCI-MSI 409600-edge      enp0s25
 30:       7815      43472       5581       5237  IR-PCI-MSI 327680-edge      xhci_hcd
 31:      29423      41453      16894      16308  IR-PCI-MSI 512000-edge      ahci[0000:00:1f.2]
 32:         21          0          0          0  IR-PCI-MSI 360448-edge      mei_me
 33:        234        129         18          5  IR-PCI-MSI 442368-edge      snd_hda_intel:card1
 34:         17         25          9          6  IR-PCI-MSI 1048576-edge
 35:      21776      66376      16760      12078  IR-PCI-MSI 32768-edge      i915
 36:       7089      20303       4455       3968  IR-PCI-MSI 2097152-edge      iwlwifi
 37:        116        855        136        140  IR-PCI-MSI 49152-edge      snd_hda_intel:card0
NMI:          0          0          0          0   Non-maskable interrupts
LOC:     310517     250892     326730     272651   Local timer interrupts
SPU:          0          0          0          0   Spurious interrupts
PMI:          0          0          0          0   Performance monitoring interrupts
IWI:          0          0          2          0   IRQ work interrupts
RTR:          0          0          0          0   APIC ICR read retries
RES:      32446      33569      28799      18822   Rescheduling interrupts
CAL:      50777      60493      62390      53925   Function call interrupts
TLB:      48661      58330      60778      51797   TLB shootdowns
TRM:          0          0          0          0   Thermal event interrupts
THR:          0          0          0          0   Threshold APIC interrupts
DFR:          0          0          0          0   Deferred Error APIC interrupts
MCE:          0          0          0          0   Machine check exceptions
MCP:         12         12         12         12   Machine check polls
ERR:          0
MIS:          0
PIN:          0          0          0          0   Posted-interrupt notification event
PIW:          0          0          0          0   Posted-interrupt wakeup event
</pre>
</div>

<p>
内核代码<a href="https://elixir.bootlin.com/linux/v4.15.4/source/fs/proc/interrupts.c">fs/proc/interrupts.c</a>和<a href="https://elixir.bootlin.com/linux/v4.15.4/source/kernel/irq/proc.c">kernel/irq/proc.c</a>：
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">seq_operations</span> <span class="org-variable-name">int_seq_ops</span> = {
        .start = int_seq_start,
        .next  = int_seq_next,
        .stop  = int_seq_stop,
        .show  = show_interrupts
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">interrupts_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filp</span>)
{
        <span class="org-keyword">return</span> seq_open(filp, &amp;int_seq_ops);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">proc_interrupts_operations</span> = {
        .open           = interrupts_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = seq_release,
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> proc_interrupts_init(<span class="org-type">void</span>)
{
        proc_create(<span class="org-string">"interrupts"</span>, 0, <span class="org-constant">NULL</span>, &amp;proc_interrupts_operations);
        <span class="org-keyword">return</span> 0;
}
<span class="org-function-name">fs_initcall</span>(proc_interrupts_init);

<span class="org-type">int</span> <span class="org-function-name">show_interrupts</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">p</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
        <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">prec</span>;

        <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">flags</span>, <span class="org-variable-name">any_count</span> = 0;
        <span class="org-type">int</span> <span class="org-variable-name">i</span> = *(<span class="org-type">loff_t</span> *) v, <span class="org-variable-name">j</span>;
        <span class="org-keyword">struct</span> <span class="org-type">irqaction</span> *<span class="org-variable-name">action</span>;
        <span class="org-keyword">struct</span> <span class="org-type">irq_desc</span> *<span class="org-variable-name">desc</span>;

        <span class="org-keyword">if</span> (i &gt; ACTUAL_NR_IRQS)
                <span class="org-keyword">return</span> 0;

        <span class="org-keyword">if</span> (i == ACTUAL_NR_IRQS)
                <span class="org-keyword">return</span> arch_show_interrupts(p, prec);

        <span class="org-comment-delimiter">/* </span><span class="org-comment">print header and calculate the width of the first column </span><span class="org-comment-delimiter">*/</span>
        <span class="org-keyword">if</span> (i == 0) {
                <span class="org-keyword">for</span> (prec = 3, j = 1000; prec &lt; 10 &amp;&amp; j &lt;= nr_irqs; ++prec)
                        j *= 10;

                seq_printf(p, <span class="org-string">"%*s"</span>, prec + 8, <span class="org-string">""</span>);
                for_each_online_cpu(j)
                        seq_printf(p, <span class="org-string">"CPU%-8d"</span>, j);
                seq_putc(p, <span class="org-string">'\n'</span>);
        }

        irq_lock_sparse();
        desc = irq_to_desc(i);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>desc)
                <span class="org-keyword">goto</span> <span class="org-constant">outsparse</span>;

        raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);
        for_each_online_cpu(j)
                any_count |= kstat_irqs_cpu(i, j);
        action = desc-&gt;action;
        <span class="org-keyword">if</span> ((<span class="org-negation-char">!</span>action || irq_desc_is_chained(desc)) &amp;&amp; <span class="org-negation-char">!</span>any_count)
                <span class="org-keyword">goto</span> <span class="org-constant">out</span>;

        seq_printf(p, <span class="org-string">"%*d: "</span>, prec, i);
        for_each_online_cpu(j)
                seq_printf(p, <span class="org-string">"%10u "</span>, kstat_irqs_cpu(i, j));

        <span class="org-keyword">if</span> (desc-&gt;irq_data.chip) {
                <span class="org-keyword">if</span> (desc-&gt;irq_data.chip-&gt;irq_print_chip)
                        desc-&gt;irq_data.chip-&gt;irq_print_chip(&amp;desc-&gt;irq_data, p);
                <span class="org-keyword">else</span> <span class="org-keyword">if</span> (desc-&gt;irq_data.chip-&gt;name)
                        seq_printf(p, <span class="org-string">" %8s"</span>, desc-&gt;irq_data.chip-&gt;name);
                <span class="org-keyword">else</span>
                        seq_printf(p, <span class="org-string">" %8s"</span>, <span class="org-string">"-"</span>);
        } <span class="org-keyword">else</span> {
                seq_printf(p, <span class="org-string">" %8s"</span>, <span class="org-string">"None"</span>);
        }
        <span class="org-keyword">if</span> (desc-&gt;irq_data.domain)
                seq_printf(p, <span class="org-string">" %*d"</span>, prec, (<span class="org-type">int</span>) desc-&gt;irq_data.hwirq);
        <span class="org-keyword">else</span>
                seq_printf(p, <span class="org-string">" %*s"</span>, prec, <span class="org-string">""</span>);
<span class="org-preprocessor">#ifdef</span> CONFIG_GENERIC_IRQ_SHOW_LEVEL
        seq_printf(p, <span class="org-string">" %-8s"</span>, irqd_is_level_type(&amp;desc-&gt;irq_data) ? <span class="org-string">"Level"</span> : <span class="org-string">"Edge"</span>);
<span class="org-preprocessor">#endif</span>
        <span class="org-keyword">if</span> (desc-&gt;name)
                seq_printf(p, <span class="org-string">"-%-8s"</span>, desc-&gt;name);

        <span class="org-keyword">if</span> (action) {
                seq_printf(p, <span class="org-string">"  %s"</span>, action-&gt;name);
                <span class="org-keyword">while</span> ((action = action-&gt;next) != <span class="org-constant">NULL</span>)
                        seq_printf(p, <span class="org-string">", %s"</span>, action-&gt;name);
        }

        seq_putc(p, <span class="org-string">'\n'</span>);
<span class="org-constant">out</span>:
        raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);
<span class="org-constant">outsparse</span>:
        irq_unlock_sparse();
        <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org5833bca" class="outline-3">
<h3 id="org5833bca"><span class="section-number-3">3.14</span> proc/&lt;pid&gt;</h3>
<div class="outline-text-3" id="text-3-14">
</div>
<div id="outline-container-org7880f0c" class="outline-4">
<h4 id="org7880f0c"><span class="section-number-4">3.14.1</span> proc/&lt;pid&gt;/oom_adj</h4>
<div class="outline-text-4" id="text-3-14-1">
<p>
调整进程OOM-killing亲和度。有效范围[-17, +15]。-17是特殊值，禁止OOM-Killing。数值越大，OOM时被选中的可能性越大。默认为0，需要CAP_SYS_RESOURCE权限修改此值。2.6.36之后版本不建议使用此方式，请使用/proc/&lt;pid&gt;/oom_score_adj代替。
</p>
</div>
</div>

<div id="outline-container-orgca662c6" class="outline-4">
<h4 id="orgca662c6"><span class="section-number-4">3.14.2</span> proc/&lt;pid&gt;/oom_score</h4>
<div class="outline-text-4" id="text-3-14-2">
<p>
查看当前进程OOM-killer分值。分数越高越容易被OOM-Killer选中。基本分值与进程占用内存相关，且随着fork数量、CPU占用、nice、privileged、是否直接存取硬件调整：
</p>
<blockquote>
<p>
This  file displays the current score that the kernel gives to this process for the purpose of selecting
a process for the OOM-killer.  A higher score means that the process is more likely to  be  selected  by
the  OOM-killer.   The  basis for this score is the amount of memory used by the process, with increases
(+) or decreases (-) for factors including:
</p>
<ul class="org-ul">
<li>whether the process creates a lot of children using fork(2) (+);</li>
<li>whether the process has been running a long time, or has used a lot of CPU time (-);</li>
<li>whether the process has a low nice value (i.e., &gt; 0) (+);</li>
<li>whether the process is privileged (-); and</li>
<li>whether the process is making direct hardware access (-).</li>
<li>The oom_score also reflects the adjustment specified by the oom_score_adj or  oom_adj  setting  for  the</li>
</ul>
<p>
process.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org7fbb3fb" class="outline-4">
<h4 id="org7fbb3fb"><span class="section-number-4">3.14.3</span> proc/&lt;pid&gt;/oom_score_adj</h4>
<div class="outline-text-4" id="text-3-14-3">
<p>
调整OOM-killer选择该进程的坏值。数值范围[-1000, +1000]。-1000表示禁止被选中。重要的常驻程序可以设置-1000禁止进程被OOM-killer选中杀死：
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;errno.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">disable_oom</span>()
{
    <span class="org-type">FILE</span> *<span class="org-variable-name">fp</span> = fopen(<span class="org-string">"/proc/self/oom_score_adj"</span>, <span class="org-string">"w"</span>);

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>fp) {
            fprintf(stderr, <span class="org-string">"open oom_score_adj failed\n"</span>);
            <span class="org-keyword">return</span> -1;
    }

    fprintf(fp, <span class="org-string">"%i"</span>, -1000);
    fclose(fp);

    <span class="org-keyword">return</span> 0;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
        <span class="org-type">int</span> <span class="org-variable-name">ret</span>;

        ret = disable_oom();
        <span class="org-keyword">if</span> (0 == ret)
                printf(<span class="org-string">"disable oom success\n"</span>);

        <span class="org-comment-delimiter">// </span><span class="org-comment">do post work ...</span>

        <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example">
disable oom success

</pre>
</div>
</div>
</div>

<div id="outline-container-orgdb8fb5e" class="outline-3">
<h3 id="orgdb8fb5e"><span class="section-number-3">3.15</span> proc/self</h3>
<div class="outline-text-3" id="text-3-15">
<p>
proc/self是一个符号链接，总是指向执行进程本身(/proc/&lt;pid&gt;)。
</p>

<div class="org-src-container">
<pre class="src src-sh">~$ ls -ld /proc/self
lrwxrwxrwx 1 root root 0 Dec 20 18:47 /proc/self -&gt; 2289
</pre>
</div>
</div>
</div>

<div id="outline-container-orge9762eb" class="outline-3">
<h3 id="orge9762eb"><span class="section-number-3">3.16</span> oom_score</h3>
<div class="outline-text-3" id="text-3-16">
<div class="org-src-container">
<pre class="src src-C">
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbe5dfea" class="outline-2">
<h2 id="orgbe5dfea"><span class="section-number-2">4</span> 内核实现</h2>
</div>

<div id="outline-container-orgc64916e" class="outline-2">
<h2 id="orgc64916e"><span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<dl class="org-dl">
<dt>IBM developer procfs、seq_file、debugfs and relayfs</dt><dd><a href="https://www.ibm.com/developerworks/cn/linux/l-kerns-usrs2/">https://www.ibm.com/developerworks/cn/linux/l-kerns-usrs2/</a></dd>
<dt>LWN Driver porting: The seq_file interface</dt><dd><a href="https://lwn.net/Articles/22355/">https://lwn.net/Articles/22355/</a></dd>
</dl>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread" class="disqus container"></div>
<script>
  var disqus_config = function () {
    this.page.url = 'http://ycode.org/linux-proc.html';
    this.page.identifier = 'linux-proc.html';
  };

  (function() {
    var d = document, s = d.createElement('script');
    s.src = 'https://yanyg.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<div class="copyright">
2012-2020 Copyright&copy; <i> YANYG - Powered by Emacs Orgmode</i>
</div>
</div>
</body>
</html>
