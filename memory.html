<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
<head>
<!-- 2018-02-25 Sun 01:44 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>内存管理技术</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="yanyg" />
<link rel="stylesheet" type="text/css" href="css/htmlize.css" />
<link rel="stylesheet" type="text/css" href="css/readtheorg.css" />
<script type="text/javascript" src="js/jquery-3.2.1.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="js/readtheorg.js"></script>
<link rel="stylesheet" type="text/css" href="css/htmlize.css" />
<link rel="stylesheet" type="text/css" href="css/readtheorg.css" />
<script type="text/javascript" src="js/jquery-3.2.1.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="js/readtheorg.js"></script>
</head>
<body>
<div id="content">
<h1 class="title">内存管理技术</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdaa6381">1. <span class="todo TODO">TODO</span> 概述</a></li>
<li><a href="#us">2. 用户态内存管理技术</a>
<ul>
<li><a href="#us-process-layout">2.1. 从程序地址空间布局谈起</a></li>
<li><a href="#us-exe-size-analysis">2.2. 可执行程序大小与地址空间分析</a></li>
<li><a href="#us-alsr">2.3. ASLR(地址空间布局随机化)策略</a></li>
<li><a href="#us-stack">2.4. 栈空间管理</a></li>
<li><a href="#us-heap">2.5. <span class="todo TODO">TODO</span> 堆内存管理</a></li>
<li><a href="#org5979c4a">2.6. 典型分配器分析</a>
<ul>
<li><a href="#org2cc23bb">2.6.1. tcmalloc</a></li>
</ul>
</li>
<li><a href="#us-mempool">2.7. <span class="todo TODO">TODO</span> 内存池的实现</a></li>
</ul>
</li>
<li><a href="#org3362aaa">3. 内核态内存管理</a>
<ul>
<li><a href="#org5e97b9c">3.1. dummy</a>
<ul>
<li><a href="#org488c521">3.1.1. brk</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3df4269">4. 读书笔记</a>
<ul>
<li><a href="#org0551547">4.1. Understanding The Linux Virtual Memory Manager(Mel Gorman, JUly 9, 2007)</a>
<ul>
<li><a href="#org878684f">4.1.1. Chapter</a></li>
</ul>
</li>
<li><a href="#org2dfa7f6">4.2. Professional Linux Kernel Architecture CN</a>
<ul>
<li><a href="#orgd032727">4.2.1. 概述</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgdaa6381" class="outline-2">
<h2 id="orgdaa6381"><span class="section-number-2">1</span> <span class="todo TODO">TODO</span> 概述</h2>
<div class="outline-text-2" id="text-1">
<p>
待定内容：介绍用户态内存使用于管理、内核态内存使用与管理、内存池、伙伴系统、虚拟内存管理等。
</p>
</div>
</div>

<div id="outline-container-org8d403c1" class="outline-2">
<h2 id="us"><a id="org8d403c1"></a><span class="section-number-2">2</span> 用户态内存管理技术</h2>
<div class="outline-text-2" id="text-us">
</div>
<div id="outline-container-orgbf51f6c" class="outline-3">
<h3 id="us-process-layout"><a id="orgbf51f6c"></a><span class="section-number-3">2.1</span> 从程序地址空间布局谈起</h3>
<div class="outline-text-3" id="text-us-process-layout">
<p>
二进制可执行文件是由特定格式的二进制代码和数据组成。常见的格式有如下三种：
</p>
<dl class="org-dl">
<dt>COFF</dt><dd>COFF是Common File Object，由UNIX System V引入，基本被ELF替代；</dd>
<dt>PE</dt><dd>PE是Portable Execuable，Windows系统基本都是此类格式。mingw查看ls类别：</dd>
</dl>
<div class="org-src-container">
<pre class="src src-sh">~$ file /bin/ls
/bin/ls: PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows
</pre>
</div>
<dl class="org-dl">
<dt>ELF</dt><dd>ELF是Executable and Linkable Format，首次在SVR4发布，1999年成为UNIX</dd>
</dl>
<p>
和类UNIX操作系统的标准二进制格式。
</p>

<p>
这里是它们的WIKI：<a href="https://en.wikipedia.org/wiki/COFF">COFF</a>， <a href="https://en.wikipedia.org/wiki/Portable_Executable">PE</a>， <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a>。
</p>

<p>
可执行文件加载到内存中时，分为代码段和数据段。数据段又进一步分为初始化数据段、未初始化数据段、栈和堆。关于进程的内存布局细节参考<a href="kernel.html#process-address-space">进程地址空间</a>，本文主要介绍数据段内存管理。
</p>

<p>
初始化数据段(initialized data)位于可执行文件data段，占用存储空间。未初始化数据段
(uninitialized data)位于BSS(Block Storage Start, 来自IBM 704机器的汇编指令。也有记作Block Start of Symbol)。未初始化或初始化为0的全局变量都在BSS段。这两种数据结构都是静态确定的，无法在运行时分配或释放。
</p>

<p>
栈(start)用于保存所有的局部变量，比如函数参数、返回地址、非整型的返回值、函数内部局部变量都保存在栈中。栈后进先出特点非常适合保存/恢复现场。因为函数的返回地址保存在栈中，修改返回地址数值，可以改变程序的预期行为，这是栈溢出攻击。为了阻止栈溢出攻击，LINUX内核添加了栈随机变量，通过修改 <code>/proc/sys/kernel/randomize_va_space</code> 为
0关闭栈随机化，为2打开栈随机化。
</p>

<p>
堆(heap)用于存放动态分配的内存。典型分配器函数 <code>malloc</code> 分配堆内存，目前比较好的分配器包括glibc的 <code>ptmalloc</code> 、google的 <code>tcmalloc</code> 、facebook的 <code>jemalloc</code> 。
LINUX系统提供 <code>brk</code> 和 <code>mmap</code> 扩展/收缩堆内存。堆内存使用不当可导致内存泄漏。通用的分配器函数（比如glibc的malloc）要考虑多种场景下的内存占用和性能的平衡问题，在某种特定场景下性能往往不是最优的，因此可以通过定制（特化）分配器函数的方式，优化堆内存的分配性能，提高其使用率、减少碎片化。这种定制的分配器称为内存池。C++
标准库STL allocator、Boost pool、memcached都是典型的内存池。2017年底整理内存技术时，翻出了2008年实现的内存池，放到了GitHub上mempool.c和mempool.h。通用内存分配器经过这么多年发展已经非常成熟，一般而言，所有的优化都是特化优化，比如，程序非常频繁的分配释放特定大小的结构体。
</p>

<p>
下图是一个典型的进程地址空间布局概要图：
</p>

<div class="figure">
<p><img src="img/memory.process-layout.png" alt="memory.process-layout.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orge86a9c2" class="outline-3">
<h3 id="us-exe-size-analysis"><a id="orge86a9c2"></a><span class="section-number-3">2.2</span> 可执行程序大小与地址空间分析</h3>
<div class="outline-text-3" id="text-us-exe-size-analysis">
<p>
先参考如下示例代码：
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">&#20195;&#30721;1&nbsp; </span>数据段示例代码</label><pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;malloc.h&gt;</span>

<span class="org-type">int</span> <span class="org-variable-name">initialized_data</span>[1024*1024] = {1};
<span class="org-type">int</span> <span class="org-variable-name">uninitialized_data</span>[1024*1024];
<span class="org-type">void</span> *<span class="org-variable-name">global_heap_data</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
        <span class="org-type">int</span> <span class="org-variable-name">stack_data</span>[1024*1024];
        <span class="org-type">void</span> *<span class="org-variable-name">heap_data</span> = malloc(1024*1024);
        global_heap_data = malloc(1024*1024);

        <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
保存为data.c编译，观察结果，大小为4.1MB左右。
</p>
<div class="org-src-container">
<pre class="src src-sh">~$ gcc -o data data.c
~$ ls -lh data
-rwxrwxr-x. 1 yanyg yanyg 4.1M Dec  5 22:22 data
ls -l data
-rwxrwxr-x. 1 yanyg yanyg 4202981 Dec  5 22:26 data
</pre>
</div>

<p>
将代码第三行initialized_data初始化为0： <code>int initialized_data[1024*1024]= {0}</code> 。再次编译观察，大小为8.5KB左右。
</p>
<div class="org-src-container">
<pre class="src src-sh">~$ gcc -o data data.c
~$ ls -lh data
-rwxrwxr-x. 1 yanyg yanyg 8.5K Dec  5 22:25 data
~$ ls -l data
-rwxrwxr-x. 1 yanyg yanyg 8629 Dec  5 22:25 data
</pre>
</div>

<p>
减少的4MB左右即为初始化数据段所占有。
</p>

<p>
使用readelf -a对initialized_data初始化为1的程序（4.1MB左右）进行进一步分析：
</p>
<p>
初始化数据段地址空间0x601040~0xa01060，长度0x400020；未初始化数据段地址空间
0xa01060~e010a0，长度0x400040。顺便说一句，_start(0x400440)为程序起始地址，而
main(400530)为main函数入口地址。
</p>
</div>
</div>

<div id="outline-container-org3ee2b57" class="outline-3">
<h3 id="us-alsr"><a id="org3ee2b57"></a><span class="section-number-3">2.3</span> ASLR(地址空间布局随机化)策略</h3>
<div class="outline-text-3" id="text-us-alsr">
<p>
上一小节分析中，通过reaelf并未看到stack和heap起始地址与长度限制，因为这是在运行时确定的。系统调用exec用load_elf_binary函数加载ELF文件，该函数检测
randomize_va_space确定是否进行堆栈随机化(fs/binfmt_elf.c)：
</p>
<dl class="org-dl">
<dt>randomize_va_space=0</dt><dd>不进行随机化</dd>
<dt>randomize_va_space=1</dt><dd>栈(stack)、vdso、mmap基地址随机化</dd>
<dt>randomize_va_space=2</dt><dd>栈(stack)、vdso、mmap，以及brk区域堆进行随机化</dd>
</dl>
<p>
上述实现称为LINUX ALSR(Address Space layout Randomization)策略，可以通过sysctl
或/proc/sys/kernel/randomize_va_space配置：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">set the value need superuser(root) privilege</span>
~# echo 0 &gt; /proc/sys/kernel/randomize_va_space
~# sysctl -n kernel.randomize_va_space
2
~$ sysctl -w kernel.randomize_va_space=0
kernel.randomize_va_space = 0
~$  sysctl -n kernel.randomize_va_space
0
</pre>
</div>
<p>
设置不同的ALSR策略，多次运行cat /proc/self/maps或ls -l /proc/self/map_files/，观察每次地址是否相同：
</p>
<div class="org-src-container">
<pre class="src src-sh">~# sysctl -w kernel.randomize_va_space=0
kernel.randomize_va_space = 0
~# ls -l /proc/self/map_files/ | grep ld-2
lr--------. 1 root root 64 Dec  5 23:48 7ffff7ddb000-7ffff7dfc000 -&gt; /usr/lib64/ld-2.17.so
lr--------. 1 root root 64 Dec  5 23:48 7ffff7ffc000-7ffff7ffd000 -&gt; /usr/lib64/ld-2.17.so
lr--------. 1 root root 64 Dec  5 23:48 7ffff7ffd000-7ffff7ffe000 -&gt; /usr/lib64/ld-2.17.so
~# ls -l /proc/self/map_files/ | grep ld-2
lr--------. 1 root root 64 Dec  5 23:49 7ffff7ddb000-7ffff7dfc000 -&gt; /usr/lib64/ld-2.17.so
lr--------. 1 root root 64 Dec  5 23:49 7ffff7ffc000-7ffff7ffd000 -&gt; /usr/lib64/ld-2.17.so
lr--------. 1 root root 64 Dec  5 23:49 7ffff7ffd000-7ffff7ffe000 -&gt; /usr/lib64/ld-2.17.so

~# sysctl -w kernel.randomize_va_space=2
kernel.randomize_va_space = 2
~# ls -l /proc/self/map_files/ | grep ld-2
lr--------. 1 root root 64 Dec  5 23:49 7f12a95e5000-7f12a9606000 -&gt; /usr/lib64/ld-2.17.so
lr--------. 1 root root 64 Dec  5 23:49 7f12a9806000-7f12a9807000 -&gt; /usr/lib64/ld-2.17.so
lr--------. 1 root root 64 Dec  5 23:49 7f12a9807000-7f12a9808000 -&gt; /usr/lib64/ld-2.17.so
~# ls -l /proc/self/map_files/ | grep ld-2
lr--------. 1 root root 64 Dec  5 23:49 7f80c2ef5000-7f80c2f16000 -&gt; /usr/lib64/ld-2.17.so
lr--------. 1 root root 64 Dec  5 23:49 7f80c3116000-7f80c3117000 -&gt; /usr/lib64/ld-2.17.so
lr--------. 1 root root 64 Dec  5 23:49 7f80c3117000-7f80c3118000 -&gt; /usr/lib64/ld-2.17.so
</pre>
</div>

<p>
64位体系下，地址空间比较充足，可以设置较大随机化范围提高安全性。brk的随机范围是
32MB(参见函数arch_randomize_brk)，stack在1GB范围内随机，vdso在随机栈(stack)之上一个PMD(Page Middle Directory, 16MB)范围再次随机，mmap随机范围受变量
/proc/sys/vm/mmap_rnd_bits控制，但会控制在2^16~2^24之间。相关代码包括
<a href="https://elixir.free-electrons.com/linux/latest/source/arch/x86/entry/vdso/vma.c">arch/x86/vdso/vma.c</a>(function vdso_addr)、<a href="https://elixir.free-electrons.com/linux/latest/source/fs/binfmt_elf.c">fs/binfmt_elf.c</a>、<a href="https://elixir.free-electrons.com/linux/latest/source/mm/mmap.c">mm/mmap.c</a>。
</p>
</div>
</div>

<div id="outline-container-org43ec16e" class="outline-3">
<h3 id="us-stack"><a id="org43ec16e"></a><span class="section-number-3">2.4</span> 栈空间管理</h3>
<div class="outline-text-3" id="text-us-stack">
<p>
用户态进程栈大小通过 <code>ulimit -s</code> 查看，通过 <code>ulimit -s new_size</code> 修改。默认大小
8192KB(8MB)。如下程序可确认此特性：
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string.h&gt;</span>

<span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TEST_STACK_SIZE
<span class="org-preprocessor">#define</span> <span class="org-variable-name">TEST_STACK_SIZE</span>         (1024*1024)
<span class="org-preprocessor">#endif</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
        <span class="org-type">char</span> <span class="org-variable-name">s</span>[TEST_STACK_SIZE];
        printf(<span class="org-string">"TEST_STACK_SIZE={%u bytes (%u KBytes)}\n"</span>,
               (<span class="org-type">unsigned</span> <span class="org-type">int</span>)TEST_STACK_SIZE,
               (<span class="org-type">unsigned</span> <span class="org-type">int</span>)TEST_STACK_SIZE/1024);
        memset(s, 0, TEST_STACK_SIZE);
        <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
用 <code>ulimit -s</code> 设置栈大小，添加GCC编译参数 <code>-DTEST_STACK_SIZE=&lt;size&gt;</code> 构建测试：
</p>
<div class="org-src-container">
<pre class="src src-sh">~$ ulimit -s
8192
~$ gcc -o stack stack.c
~$ ./stack
<span class="org-variable-name">TEST_STACK_SIZE</span>={1048576 bytes (1024 KBytes)}
~$ gcc -o stack stack.c -DTEST_STACK_SIZE=$((1024*1024*7))
~$ ./stack
<span class="org-variable-name">TEST_STACK_SIZE</span>={7340032 bytes (7168 KBytes)}
~$ gcc -o stack stack.c -DTEST_STACK_SIZE=$((1024*1024*8))
~$ ./stack
Segmentation fault (core dumped)
~$ ulimit -s 10240
~$ ulimit -s
10240
~$ gcc -o stack stack.c -DTEST_STACK_SIZE=$((1024*1024*8))
~$ ./stack
<span class="org-variable-name">TEST_STACK_SIZE</span>={8388608 bytes (8192 KBytes)}
~$ gcc -o stack stack.c -DTEST_STACK_SIZE=$((1024*1024*9))
~$ ./stack
<span class="org-variable-name">TEST_STACK_SIZE</span>={9437184 bytes (9216 KBytes)}
~$ gcc -o stack stack.c -DTEST_STACK_SIZE=$((1024*1024*10))
~$ ./stack
Segmentation fault (core dumped)
</pre>
</div>
<p>
栈上定义变量大于等于栈大小时，运行出现段错误，这是栈溢出导致的问题。程序启动、调用已经占用一部分栈空间，因此当栈上局部变量空间略小于栈大小时，也会溢出，具体数据与平台、系统、函数调用深度相关。上述测试程序，只有TEST_STACK_SIZE小于栈大小
10KB及以上时才能避免段错误。
</p>
</div>
</div>

<div id="outline-container-orge33d2b0" class="outline-3">
<h3 id="us-heap"><a id="orge33d2b0"></a><span class="section-number-3">2.5</span> <span class="todo TODO">TODO</span> 堆内存管理</h3>
<div class="outline-text-3" id="text-us-heap">
<ul class="org-ul">
<li>内存泄漏、进程退出时全部回收、brk与mmap</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;malloc.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
        <span class="org-type">int</span> <span class="org-variable-name">i</span>;
        <span class="org-type">void</span> *<span class="org-variable-name">p</span>[10000];
        printf(<span class="org-string">"Test memory usage\n"</span>);
        <span class="org-keyword">for</span> (i = 0; i &lt; 10000; ++i) {
                p[i] = malloc(1024*512);
                <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>p[i]) {
                        fprintf(stderr, <span class="org-string">"alloc %d failed\n"</span>, i);
                }
                memset(p[i], 0, 1024*512);
        }

        printf(<span class="org-string">"Watch your memory usage, then press any key continue ...\n"</span>);
        getchar();

        printf(<span class="org-string">"Do free ...\n"</span>);
        <span class="org-keyword">for</span> (i = 0; i &lt; 10000; ++i) {
                free(p[i]);
        }

        printf(<span class="org-string">"Watch your memory usage, then press any key exit ...\n"</span>);
        getchar();

        <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org5979c4a" class="outline-3">
<h3 id="org5979c4a"><span class="section-number-3">2.6</span> 典型分配器分析</h3>
<div class="outline-text-3" id="text-2-6">
</div>
<div id="outline-container-org2cc23bb" class="outline-4">
<h4 id="org2cc23bb"><span class="section-number-4">2.6.1</span> tcmalloc</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
<a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">http://goog-perftools.sourceforge.net/doc/tcmalloc.html</a>
</p>
</div>
</div>
</div>


<div id="outline-container-org4002d30" class="outline-3">
<h3 id="us-mempool"><a id="org4002d30"></a><span class="section-number-3">2.7</span> <span class="todo TODO">TODO</span> 内存池的实现</h3>
<div class="outline-text-3" id="text-us-mempool">
<ul class="org-ul">
<li>特化实现、均衡技术、缓存对齐与性能</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org3362aaa" class="outline-2">
<h2 id="org3362aaa"><span class="section-number-2">3</span> 内核态内存管理</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org5e97b9c" class="outline-3">
<h3 id="org5e97b9c"><span class="section-number-3">3.1</span> dummy</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-org488c521" class="outline-4">
<h4 id="org488c521"><span class="section-number-4">3.1.1</span> brk</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
brk stands for break. means program break
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-comment-delimiter">/* </span><span class="org-comment">mm/mmap.c </span><span class="org-comment-delimiter">*/</span>
<span class="org-function-name">SYSCALL_DEFINE1</span>(brk, <span class="org-type">unsigned</span> <span class="org-type">long</span>, brk)
{
    ...
}
sched.<span class="org-constant">h</span>: <span class="org-constant">task_struct</span>: <span class="org-type">brk_randomized</span>
<span class="org-variable-name">CONFIG_COMPAT_BRK</span>: disable heap randomization
/proc/sys/kernel/randomize_va_space
sysctl -n kernel.randomize_va_space
Generate two:
Same:
echo 0 &gt; /proc/sys/kernel/randomize_va_space; cat /proc/self/maps &gt; cat.maps.1; cat /proc/self/maps &gt; cat.maps.2; <span class="org-type">diff</span> <span class="org-variable-name">cat</span>.maps.[12] &gt;/dev/null; echo $?

Diff:
echo 2 &gt; /proc/sys/kernel/randomize_va_space; cat /proc/self/maps &gt; cat.maps.1; cat /proc/self/maps &gt; cat.maps.2; <span class="org-type">diff</span> <span class="org-variable-name">cat</span>.maps.[12] &gt;/dev/null; echo $?
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org3df4269" class="outline-2">
<h2 id="org3df4269"><span class="section-number-2">4</span> 读书笔记</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org0551547" class="outline-3">
<h3 id="org0551547"><span class="section-number-3">4.1</span> Understanding The Linux Virtual Memory Manager(Mel Gorman, JUly 9, 2007)</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org878684f" class="outline-4">
<h4 id="org878684f"><span class="section-number-4">4.1.1</span> Chapter</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
1
</p>
</div>
</div>
</div>
<div id="outline-container-org2dfa7f6" class="outline-3">
<h3 id="org2dfa7f6"><span class="section-number-3">4.2</span> Professional Linux Kernel Architecture CN</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-orgd032727" class="outline-4">
<h4 id="orgd032727"><span class="section-number-4">4.2.1</span> 概述</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
领域：
</p>
<ul class="org-ul">
<li>物理内存页的管理</li>
<li>分配大块内存的伙伴系统</li>
<li>分配小块内存的slab、slob、slub分配器</li>
<li>分配非连续内存块的vmalloc机制</li>
<li>进程的地址空间</li>
</ul>

<p>
LINUX将虚拟地址空间分两部分，底部较大用于用户进程，顶部则内核专用。32位系统下的典型分配是3:1。
PAE开启后32位系统可达64GB，但不是同时可访问。
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread" class="disqus container"></div>
<script>
  var disqus_config = function () {
    this.page.url = 'http://ycode.org/memory.html';
    this.page.identifier = 'memory.html';
  };

  (function() {
    var d = document, s = d.createElement('script');
    s.src = 'https://yanyg.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<div class="copyright">
2012-2020 Copyright&copy; <i> YANYG - Powered by Emacs Orgmode</i>
</div>
</div>
</body>
</html>
