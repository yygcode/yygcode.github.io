<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-04-03 Wed 01:27 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>In Search of an Understandable Consensus Algorithm (Extended Version)</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Diego Ongaro and John Ousterhout, Stanford University" />
<link rel="stylesheet" type="text/css" href="../styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../styles/readtheorg/css/readtheorg.css"/>
<script src="../styles/jquery/2.1.3/jquery.min.js"></script>
<script src="../styles/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="../styles/readtheorg/js/readtheorg.js"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="paper-index.html"> HOME </a>
</div><div id="content">
<h1 class="title">In Search of an Understandable Consensus Algorithm (Extended Version)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org788769f">DECLARATION</a></li>
<li><a href="#org257d8d0">Abstract</a></li>
<li><a href="#org9a16b83">1. Introduction</a></li>
<li><a href="#org4eba1b7">2. Replicated state machines</a></li>
</ul>
</div>
</div>

<div id="outline-container-org788769f" class="outline-2">
<h2 id="org788769f">DECLARATION</h2>
<div class="outline-text-2" id="text-org788769f">
<p>
This page is the In Search of an Understandable Consensus Algorithm
(Extended Version)  paper. Original Paper Link
is: <a href="https://raft.github.io/raft.pdf">https://raft.github.io/raft.pdf</a>
</p>

<p>
In Search of an Understandable Consensus Algorithm<br />
(Extended Version)<br />
Diego Ongaro and John Ousterhout<br />
Stanford University
</p>
</div>
</div>

<div id="outline-container-org257d8d0" class="outline-2">
<h2 id="org257d8d0">Abstract</h2>
<div class="outline-text-2" id="text-org257d8d0">
<p>
Raft is a consensus algorithm for managing a replicated log. It produces a
result equivalent to (multi-)Paxos, and it is as efficient as Paxos, but its
structure is different from Paxos; this makes Raft more understandable than
Paxos and also provides a better foundation for building practical systems.
In order to enhance understandability, Raft separates the key elements of
consensus, such as leader election, log replication, and safety, and it enforces
a stronger degree of coherency to reduce the number of states that must be
considered. Results from a user study demonstrate that Raft is easier for
students to learn than Paxos. Raft also includes a new mechanism for changing
the cluster membership, which uses overlapping majorities to guarantee safety.
</p>
</div>
</div>

<div id="outline-container-org9a16b83" class="outline-2">
<h2 id="org9a16b83"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Consensus algorithms allow a collection of machines to work as a coherent group
that can survive the failures of some of its members. Because of this, they play
a key role in building reliable large-scale software systems. Paxos [15, 16] has
dominated the discussion of consensus algorithms over the last decade: most
implementations of consensus are based on Paxos or influenced by it, and Paxos
has become the primary vehicle used to teach students about consensus.
</p>

<p>
Unfortunately, Paxos is quite difficult to understand, in spite of numerous
attempts to make it more approachable. Furthermore, its architecture requires
complex changes to support practical systems. As a result, both system builders
and students struggle with Paxos.
</p>

<p>
After struggling with Paxos ourselves, we set out to find a new consensus
algorithm that could provide a better foundation for system building and
education. Our approach was unusual in that our primary goal was
understandability: could we define a consensus algorithm for practical systems
and describe it in a way that is significantly easier to learn than Paxos?
Furthermore, we wanted the algorithm to facilitate the development of intuitions
that are essential for system builders. It was important not just for the
algorithm to work, but for it to be obvious why it works.
</p>

<p>
The result of this work is a consensus algorithm called Raft. In designing Raft
we applied specific techniques to improve understandability,including
decomposition (Raft separates leader election, log replication, and safety) and
This tech report is an extended version of [32]; additional material is noted
with a gray bar in the margin. Published May 20, 2014. state space reduction
(relative to Paxos, Raft reduces the degree of nondeterminism and the ways
servers can be inconsistent with each other). A user study with 43 students
at two universities shows that Raft is significantly easier to understand than
Paxos: after learning both algorithms, 33 of these students were able to answer
questions about Raft better than questions about Paxos.
</p>

<p>
Raft is similar in many ways to existing consensus algorithms (most notably, Oki
and Liskov’s Viewstamped Replication [29, 22]), but it has several novel
features:
</p>

<p>
1/. Strong leader: Raft uses a stronger form of leadership than other consensus
algorithms. For example, log entries only flow from the leader to other servers.
This simplifies the management of the replicated log and makes Raft easier to
understand.
</p>

<p>
2/. Leader election: Raft uses randomized timers to elect leaders. This adds
only a small amount of mechanism to the heartbeats already required for any
consensus algorithm, while resolving conflicts simply and rapidly.
</p>

<p>
3/. Membership changes: Raft’s mechanism for changing the set of servers in the
cluster uses a new joint consensus approach where the majorities of two
different configurations overlap during transitions. This allows the cluster to
continue operating normally during configuration changes.
</p>

<p>
We believe that Raft is superior to Paxos and other consensus algorithms, both
for educational purposes and as a foundation for implementation. It is simpler
and more understandable than other algorithms; it is described completely enough
to meet the needs of a practical system; it has several open-source
implementations and is used by several companies; its safety properties have
been formally specified and proven; and its efficiency is comparable to other
algorithms.
</p>

<p>
The remainder of the paper introduces the replicated state machine problem
(Section 2), discusses the strengths and weaknesses of Paxos (Section 3),
describes our general approach to understandability (Section 4), presents the
Raft consensus algorithm (Sections 5–8), evaluates Raft (Section 9), and
discusses related work (Section 10).
</p>
</div>
</div>

<div id="outline-container-org4eba1b7" class="outline-2">
<h2 id="org4eba1b7"><span class="section-number-2">2</span> Replicated state machines</h2>
<div class="outline-text-2" id="text-2">
<p>
Consensus algorithms typically arise in the context of replicated state machines
[37]. In this approach, state machines on a collection of servers compute
identical copies of the same state and can continue operating even if some of
the servers are down. Replicated state machines are used to solve a variety of
fault tolerance problems in distributed systems. For example, large-scale
systems that have a single cluster leader, such as GFS [8], HDFS [38], and
RAMCloud [33], typically use a separate replicated state machine to manage
leader election and store configuration information that must survive leader
crashes. Examples of replicated state machines include Chubby [2] and
ZooKeeper [11].
</p>

<p>
manages a replicated log containing state machine commands from clients. The<br />
state machines process identical sequences of commands from the logs, so they<br />
produce the same outputs.
</p>

<div id="org89d8216" class="figure">
<p><img src="img/raft-figure1.jpg" alt="raft-figure1.jpg" />
</p>
</div>

<p>
Replicated state machines are typically implemented using a replicated log, as
shown in Figure 1. Each server stores a log containing a series of commands,
which its state machine executes in order. Each log contains the same commands
in the same order, so each state machine processes the same sequence of
commands. Since the state machines are deterministic, each computes the same
state and the same sequence of outputs.
</p>

<p>
Keeping the replicated log consistent is the job of the
consensus algorithm. The consensus module on a server
receives commands from clients and adds them to its log.
It communicates with the consensus modules on other
servers to ensure that every log eventually contains the
same requests in the same order, even if some servers fail.
Once commands are properly replicated, each server’s
state machine processes them in log order, and the out-
puts are returned to clients. As a result, the servers appear
to form a single, highly reliable state machine.
Consensus algorithms for practical systems typically
have the following properties:
• They ensure safety (never returning an incorrect re-
sult) under all non-Byzantine conditions, including
network delays, partitions, and packet loss, duplica-
tion, and reordering.
• They are fully functional (available) as long as any
majority of the servers are operational and can com-
municate with each other and with clients. Thus, a
typical cluster of five servers can tolerate the failure
of any two servers. Servers are assumed to fail by
stopping; they may later recover from state on stable
storage and rejoin the cluster.
• They do not depend on timing to ensure the consis-
tency of the logs: faulty clocks and extreme message
delays can, at worst, cause availability problems.
• In the common case, a command can complete as
soon as a majority of the cluster has responded to a
single round of remote procedure calls; a minority of
slow servers need not impact overall system perfor-
mance.
3 What’s wrong with Paxos?
Over the last ten years, Leslie Lamport’s Paxos proto-
col [15] has become almost synonymous with consensus:
it is the protocol most commonly taught in courses, and
most implementations of consensus use it as a starting
point. Paxos first defines a protocol capable of reaching
agreement on a single decision, such as a single replicated
log entry. We refer to this subset as single-decree Paxos.
Paxos then combines multiple instances of this protocol to
facilitate a series of decisions such as a log (multi-Paxos).
Paxos ensures both safety and liveness, and it supports
changes in cluster membership. Its correctness has been
proven, and it is efficient in the normal case.
Unfortunately, Paxos has two significant drawbacks.
The first drawback is that Paxos is exceptionally diffi-
cult to understand. The full explanation [15] is notori-
ously opaque; few people succeed in understanding it, and
only with great effort. As a result, there have been several
attempts to explain Paxos in simpler terms [16, 20, 21].
These explanations focus on the single-decree subset, yet
they are still challenging. In an informal survey of atten-
dees at NSDI 2012, we found few people who were com-
fortable with Paxos, even among seasoned researchers.
We struggled with Paxos ourselves; we were not able to
understand the complete protocol until after reading sev-
eral simplified explanations and designing our own alter-
native protocol, a process that took almost a year.
We hypothesize that Paxos’ opaqueness derives from
its choice of the single-decree subset as its foundation.
Single-decree Paxos is dense and subtle: it is divided into
two stages that do not have simple intuitive explanations
and cannot be understood independently. Because of this,
it is difficult to develop intuitions about why the single-
decree protocol works. The composition rules for multi-
Paxos add significant additional complexity and subtlety.
We believe that the overall problem of reaching consensus
on multiple decisions (i.e., a log instead of a single entry)
can be decomposed in other ways that are more direct and
obvious.
The second problem with Paxos is that it does not pro-
vide a good foundation for building practical implemen-
tations. One reason is that there is no widely agreed-
upon algorithm for multi-Paxos. Lamport’s descriptions
are mostly about single-decree Paxos; he sketched possi-
ble approaches to multi-Paxos, but many details are miss-
ing. There have been several attempts to flesh out and op-
timize Paxos, such as [26], [39], and [13], but these differ
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread" class="disqus container"></div>
<script>
  var disqus_config = function () {
    this.page.url = 'http://ycode.org/papers/consensus-raft-extended-version.html';
    this.page.identifier = 'consensus-raft-extended-version.html';
  };

  (function() {
    var d = document, s = d.createElement('script');
    s.src = 'https://yanyg.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</body>
</html>
